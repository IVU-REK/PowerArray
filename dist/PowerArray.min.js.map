{"version":3,"sources":["webpack:///PowerArray.min.js","webpack:///webpack/bootstrap d4591b020b3c77f3cb2d","webpack:///./src/PowerArray.js","webpack:///./src/main.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","global","mainContainer","isModule","isBrowser","window","pa","Error","object","constructor","Array","paIsArray","paArray","undefined","ol","Collection","getArray","length","Range","from","to","step","IsNumeric","parseFloat","result","currVal","push","utils","DataTypes","String","Number","Date","Boolean","Object","ArrayOfObjects","ArrayOfPrimitives","RegExp","Function","Null","Undefined","IsArrayOfObjects","val","l","GetTypeOf","parseBoolean","str","throwIfNotMatch","isNullEmptyOrUndefined","strU","toUpperCase","what","t","element","analyzeData","ArgumentsToArray","args","i","generateUid","prefix","sufix","getRandom4Chars","Math","floor","random","toString","substring","propsToArray","obj","valueProcessor","prop","hasOwnProperty","property","value","paEachParalellsHelper","CheckParalellTaskStates","paralellId","paralell","currentParalellIds","CompletedTasks","TotalProcesses","actionKeys","Runeach","TaskState","eventKeys","RuneachDone","paWhereHelper","FillConditions","item","conditions","condition","subArray","itemType","column","Where","EqualTo3","ProcessConditionObject","whereConditions","keepOrder","isArrayOfConditions","justFirst","justIndexes","w","lw","assert","fc","whereConditionObject","realConditions","RunEach","subCondition","this","equals","a","b","enforce_properties_order","cyclic","_equals","s","x","y","valueOf","source","ignoreCase","multiline","lastIndex","reference_equals","properties","_reference_equals","object_references","auxiliaryFunctions","Contains","enforcePropsOrder","isIndexable","typeToEvaluate","getMonth","indexOf","Between","excludeExactMatches","console","warn","EndsWith","value2","endsWithString","substr","StartsWith","GreaterOrEqualThan","GreaterThan","SmallerOrEqualThan","SmallerThan","NotEqualTo3","EqualTo2","NotEqualTo2","IsUndefined","IsDefined","In","list","arguments","prototype","slice","NotIn","EqualTo","func","Like","NotLike","LikeIgnoreCase","valueCaseInsensitive","NotLikeIgnoreCase","IsTruthy","IsFalsy","IsTrue","IsFalse","IsEmpty","IsNotEmpty","IsNull","IsNotNull","IsNaN","isNaN","IsNotNaN","num","isFinite","IsInteger","parseInt","prototypedFunctions_Array","getIndexByProperty","valueToSearchFor","ia","io","objectsArray","la","lo","tmpObj","arg","isFunc","argName","GetPropertyFlat","includeDuplicates","includeUndefineds","array","GetByProperty","results","task","callback","progress","Sort","sortConditions","conditionType","Ascending","Asc","sort","AscendingIgnoringCase","AscIgnoringCase","toLowerCase","localeCompare","e","Descending","Desc","DescendingIgnoringCase","DescIgnoringCase","_validSortConfigStrings","sortDirection","currentColumn","cycleValue","Exists","First","Remove","first","FirstIndex","splice","Distinct","Iterate","Collect","WhereIndexes","tmp","message","apply","Count","Average","Bounds","alc","arrayItemValue","al","currentArgName","min","max","Max","Take","count","skip","added","Last","idx","newArray","functionsToAttach","currentFunctionName","isArray"],"mappings":"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","file":"PowerArray.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {var mainContainer, module = module, isModule = false, isBrowser = true;\r\n\tif (typeof module !== \"undefined\") {\r\n\t    module.exports = {};\r\n\t    isModule = true;\r\n\t}\r\n\t\r\n\tif (typeof window === 'object') {\r\n\t    mainContainer = window;\r\n\t} else {\r\n\t    isBrowser = false;\r\n\t    mainContainer = global;\r\n\t}\r\n\tif(mainContainer.pa) {\r\n\t\tthrow new Error('PowerArray => Cannot load, global variable \"pa\" already exists. Loading twice?');\r\n\t}\r\n\tmainContainer.pa = function (object) {\r\n\t    if (object.constructor === Array || object.paIsArray) {\r\n\t        return new paArray(object);\r\n\t    } else {\r\n\t        //console.warn('PowerArray => The passed object is not natively an array. Trying to handle it as an array-like object...')\r\n\t        if ((mainContainer.ol !== undefined && ol.Collection) && object instanceof ol.Collection) {\r\n\t          //  console.log('Compatible openlayers object detected (ol.Collection)');\r\n\t            return paArray(object.getArray());\r\n\t        }\r\n\t        if (object.length === undefined) {\r\n\t            throw new Error('PowerArray => The passed object is not an array, or usable as such.');\r\n\t        }\r\n\t        return new paArray(object);\r\n\t    }\r\n\t};\r\n\t/*\r\n\tfunctions directly bound to the pa object:\r\n\t\r\n\t */\r\n\tmainContainer.pa.Range = function (from, to, step) {\r\n\t    if (!pa.IsNumeric(from)) {\r\n\t        throw new Error('PowerArray => Range fuction => The parameter \"from\" must be numeric. Wrong value is \"' + from + '\"');\r\n\t    }\r\n\t    if (!pa.IsNumeric(to)) {\r\n\t        throw new Error('PowerArray => Range fuction => The parameter \"to\" must be numeric. Received value is \"' + to + '\"');\r\n\t    }\r\n\t    if (!pa.IsNumeric(step)) {\r\n\t        throw new Error('PowerArray => Range fuction => The parameter \"step\" must be numeric. Received value is \"' + step + '\"');\r\n\t    }\r\n\t\r\n\t    from = parseFloat(from);\r\n\t    to = parseFloat(to);\r\n\t    step = parseFloat(step);\r\n\t\r\n\t    var result = [], i, l, currVal = from;\r\n\t    while (currVal < to) {\r\n\t        result.push(currVal);\r\n\t        currVal += step;\r\n\t    }\r\n\t    result.push(to);\r\n\t    return result;\r\n\t};\r\n\tmainContainer.pa.utils = {}\r\n\tmainContainer.pa.utils = {\r\n\t    DataTypes: {\r\n\t        String: 'String',\r\n\t        Number: 'Number',\r\n\t        Date: 'Date',\r\n\t        Boolean: 'Boolean',\r\n\t        Object: 'Object',\r\n\t        ArrayOfObjects: 'ArrayOfObjects',\r\n\t        ArrayOfPrimitives: 'ArrayOfPrimitives',\r\n\t        RegExp: 'RegExp',\r\n\t        Function: 'Function',\r\n\t        Null: 'Null',\r\n\t        Undefined: 'Undefined'\r\n\t    }, IsArrayOfObjects: function (val) {\r\n\t        var l;\r\n\t        if (!val.paIsArray || val.length === undefined) {\r\n\t            return false;\r\n\t        }\r\n\t        l = val.length;\r\n\t        while (l--) {\r\n\t            //TODO: this could fail in collections having objects but one undefined\r\n\t            if (pa.utils.GetTypeOf(val[l]) !== pa.utils.DataTypes.Object) {\r\n\t                return false;\r\n\t            }\r\n\t        }\r\n\t        return true;\r\n\t    },\r\n\t    /**\r\n\t     * Parses a string to boolean value. This function searches strictly for the strings \"true\", \"True\", \"trUE\", \"falsE\", etc.\r\n\t     * @param str the string to be evaluated\r\n\t     * @param throwIfNotMatch Boolean, if true, an exception will be raised if the string does not match. If false, null will be returned\r\n\t     * @returns {*} boolean value if string matches, null if not\r\n\t     */\r\n\t    parseBoolean: function (str, throwIfNotMatch) {\r\n\t        if (!pa.utils.isNullEmptyOrUndefined(str)) {\r\n\t            var strU = str.toUpperCase();\r\n\t            if (strU === \"TRUE\") {\r\n\t                return true;\r\n\t            }\r\n\t            if (strU === \"FALSE\") {\r\n\t                return false;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        if (throwIfNotMatch) {\r\n\t            throw new Error(\"The string passed to function parseBoolean (\" + str + \") doesn't match with any valid string\");\r\n\t        }\r\n\t\r\n\t        return null;\r\n\t    }, /**\r\n\t     * evaluate if a number or a string is undefined \"\" or null and return true or false\r\n\t     * @param what the element to evaluate\r\n\t     * @returns {boolean}\r\n\t     * @constructor\r\n\t     */\r\n\t    isNullEmptyOrUndefined: function (what) {\r\n\t        // null has to be evaluated before checking typeof\r\n\t        if (what === null) {\r\n\t            return true;\r\n\t        }\r\n\t        var t = typeof what;\r\n\t        if (t === \"boolean\") {\r\n\t            return false;\r\n\t        }\r\n\t\r\n\t        if (t !== \"number\" && t !== \"string\" && t !== \"undefined\") {\r\n\t            throw new Error(\"PowerArray => The function IsNullOrEmpty is designed to evaluate strings and numbers, but something different was provided (\" + t + \")\");\r\n\t        }\r\n\t\r\n\t        if (t === \"number\" && what === 0) {\r\n\t            return false;\r\n\t        }\r\n\t\r\n\t        if (!what) {\r\n\t            return true;\r\n\t        }\r\n\t        return (what + \"\").length === 0;\r\n\t    },\r\n\t    GetTypeOf: function (element, analyzeData) {\r\n\t\r\n\t        if (element === null) {\r\n\t            return pa.utils.DataTypes.Null;\r\n\t        }\r\n\t\r\n\t        if (element === undefined) {\r\n\t            return pa.utils.DataTypes.Undefined;\r\n\t        }\r\n\t        var to = typeof element;\r\n\t        switch (to) {\r\n\t            case 'string':\r\n\t                return pa.utils.DataTypes.String;\r\n\t            case 'function':\r\n\t                return pa.utils.DataTypes.Function;\r\n\t            case 'number':\r\n\t                return pa.utils.DataTypes.Number;\r\n\t            case 'boolean':\r\n\t                return pa.utils.DataTypes.Boolean;\r\n\t            case 'object':\r\n\t                //check hidden types\r\n\t                if (element instanceof String) {\r\n\t                    return pa.utils.DataTypes.String;\r\n\t                }\r\n\t\r\n\t                if (element instanceof Date) {\r\n\t                    return pa.utils.DataTypes.Date;\r\n\t                }\r\n\t\r\n\t                if (element instanceof Number) {\r\n\t                    return pa.utils.DataTypes.Number;\r\n\t                }\r\n\t\r\n\t                if (element instanceof RegExp) {\r\n\t                    return pa.utils.DataTypes.RegExp;\r\n\t                }\r\n\t                if (element.paIsArray) {\r\n\t                    // If its an array of objects, it has to be handled different,\r\n\t                    if (analyzeData && pa.utils.IsArrayOfObjects(element)) {\r\n\t                        return pa.utils.DataTypes.ArrayOfObjects;\r\n\t                    } else {\r\n\t                        return pa.utils.DataTypes.ArrayOfPrimitives;\r\n\t                    }\r\n\t                }\r\n\t                return pa.utils.DataTypes.Object;\r\n\t            default:\r\n\t                //any others\r\n\t                throw new Error(\"PowerArray Error : Unknown Datatype!\");\r\n\t        }\r\n\t    },\r\n\t    ArgumentsToArray: function (args, from, to) {\r\n\t        var i = from | 0, l = to || args.length, result = [];\r\n\t        for (; i < l; i++) {\r\n\t            result.push(args[i]);\r\n\t        }\r\n\t        return result;\r\n\t    },\r\n\t    generateUid: function (prefix, sufix) {\r\n\t        function getRandom4Chars() {\r\n\t            return Math.floor((1 + Math.random()) * 0x10000)\r\n\t                .toString(16)\r\n\t                .substring(1);\r\n\t        }\r\n\t        return ((prefix !== undefined) ? prefix + '-' : '') +\r\n\t            getRandom4Chars() + '-' +\r\n\t            getRandom4Chars() + '-' +\r\n\t            getRandom4Chars() +\r\n\t            getRandom4Chars() + ((sufix !== undefined) ? '-' + sufix : '');\r\n\t    },\r\n\t    propsToArray: function (obj, valueProcessor) {\r\n\t        var result = [];\r\n\t        for (var prop in obj) {\r\n\t            if (obj.hasOwnProperty(prop)) {\r\n\t                result.push({ property: prop, value: (valueProcessor) ? valueProcessor(obj[prop]) : obj[prop] });\r\n\t            }\r\n\t        }\r\n\t        return result;\r\n\t    }\r\n\t};\r\n\t\r\n\tmainContainer.pa.paEachParalellsHelper = {\r\n\t    CheckParalellTaskStates: function (paralellId) {\r\n\t        var paralell = mainContainer.pa.paEachParalellsHelper.currentParalellIds[paralellId];\r\n\t        return paralell.CompletedTasks === paralell.TotalProcesses;\r\n\t    },\r\n\t    currentParalellIds: {},\r\n\t    actionKeys: {\r\n\t        Runeach: 'RunEach',\r\n\t        TaskState: 'TaskState'\r\n\t    },\r\n\t    eventKeys: {\r\n\t        RuneachDone: 'RuneachDone',\r\n\t        TaskState: 'TaskStateResponse'\r\n\t    }\r\n\t};\r\n\tmainContainer.pa.paWhereHelper = {\r\n\t    FillConditions: function (item, conditions) {\r\n\t        var l = conditions.length, condition, result, subArray;\r\n\t        while (l--) {\r\n\t            condition = conditions[l];\r\n\t            //conditions can be functions or single values, if there are single values, they have to ve evaluated by\r\n\t            //===. if they are functions everything should continue as by default\r\n\t            if (typeof condition.condition !== 'function') {\r\n\t                //if the condition is an object, it's necessary to handle it different.\r\n\t                //If that's the case we start internally another Where() call, but we know that we are\r\n\t                //evaluating pro Where call just ONE item and it could be very expensive. TODO: optimize this somehow!\r\n\t                if (mainContainer.pa.utils.GetTypeOf(condition.condition) === mainContainer.pa.utils.DataTypes.Object) {\r\n\t                    var itemType = mainContainer.pa.utils.GetTypeOf(item[condition.column], true);\r\n\t\r\n\t                    switch (itemType) {\r\n\t                        case mainContainer.pa.utils.DataTypes.ArrayOfObjects:\r\n\t                        case mainContainer.pa.utils.DataTypes.ArrayOfPrimitives:\r\n\t\r\n\t                            result = item[condition.column].Where.call(item[condition.column], condition.condition, false, true);\r\n\t                            //when sending true als \"justFirst\", Where() will return the first found element, not an array,\r\n\t                            //because i'm sending true for performance reasons, it's necessary to evaluate the result with undefined\r\n\t                            //instead of: \"return result.length > 0;\" it's now \"return result !== undefined;\"\r\n\t                            if (result !== undefined) {\r\n\t                                continue;\r\n\t                            } else {\r\n\t                                return false;\r\n\t                            }\r\n\t                            break;\r\n\t                        case mainContainer.pa.utils.DataTypes.Object:\r\n\t                            subArray = pa([item[condition.column]]);\r\n\t                            result = subArray.Where.call(subArray, condition.condition, false, true);\r\n\t                            if (result !== undefined) {//See previous comment about justFirst param\r\n\t                                continue;\r\n\t                            } else {\r\n\t                                return false;\r\n\t                            }\r\n\t                    }\r\n\t                }\r\n\t                condition.condition = pa.EqualTo3(condition.condition); //transforms an explicit value into an === evaluation\r\n\t            }\r\n\t\r\n\t            if (!item || !condition.condition(item[condition.column])) { //if one condition is not fulfilled, just return false;\r\n\t                return false;\r\n\t            }\r\n\t        }\r\n\t        return true;\r\n\t    },\r\n\t    ProcessConditionObject: function (whereConditions, keepOrder, isArrayOfConditions, justFirst, justIndexes) {\r\n\t        //to call this function, \"this\" should be an array!\r\n\t        var fc = mainContainer.pa.paWhereHelper.FillConditions,\r\n\t            i, w, item, lw, assert, l, result = [];\r\n\t\r\n\t        if (!isArrayOfConditions) {\r\n\t            //whereConditions is not an array, but i need it in that form\r\n\t            whereConditions = [whereConditions];\r\n\t        }\r\n\t\r\n\t        //Where conditions must be processed in order\r\n\t        for (i = 0, l = whereConditions.length; i < l; i++) {\r\n\t            var whereConditionObject = whereConditions[i], realConditions = [];\r\n\t            if (typeof whereConditionObject === 'function') {\r\n\t                realConditions.push({\r\n\t                    column: property,\r\n\t                    condition: whereConditionObject\r\n\t                });\r\n\t            } else {\r\n\t                for (var property in whereConditionObject) {\r\n\t                    if (property !== 'realConditions' && whereConditionObject.hasOwnProperty(property)) {\r\n\t                        //transform the keys into a better object with properties Column and Condition\r\n\t\r\n\t                        //if whereConditionObject[property] is an array, that means that its a multi filter for a single column, for example: array.Where({age : [GreatherThan(33), BiggerThan(21)], otherField : '33'   });\r\n\t                        if (whereConditionObject[property] && whereConditionObject[property].paIsArray) {\r\n\t                            /** MULTIPLE CONDITIONS FOR A SINGLE PROPERTY. Pushed on the realconditions as an AND **/\r\n\t                            whereConditionObject[property].RunEach(function (subCondition) {\r\n\t                                realConditions.push({\r\n\t                                    column: property,\r\n\t                                    condition: subCondition\r\n\t                                });\r\n\t                            });\r\n\t                        } else {\r\n\t                            realConditions.push({\r\n\t                                column: property,\r\n\t                                condition: whereConditionObject[property]\r\n\t                            });\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t\r\n\t            whereConditionObject.realConditions = realConditions; //attach the result of this loop direct to the whereConditionObject\r\n\t        }\r\n\t        //Real conditions stored\r\n\t        l = this.length;\r\n\t        if (keepOrder) { //Anti DRY pattern ;( but as long as it still being small will continue this way to improve performance\r\n\t            for (i = 0; i < l; i++) {\r\n\t                item = this[i];\r\n\t                for (w = 0, lw = whereConditions.length; w < lw; w++) {\r\n\t                    assert = fc(item, whereConditions[w].realConditions);\r\n\t                    if (assert) {\r\n\t                        break;\r\n\t                    }\r\n\t                }\r\n\t                if (assert) {\r\n\t                    if (justFirst) {\r\n\t                        return (justIndexes) ? i : item;\r\n\t                    }\r\n\t                    result.push((justIndexes) ? i : item);\r\n\t                }\r\n\t            }\r\n\t        } else {\r\n\t            while (l--) {\r\n\t                item = this[l];\r\n\t                for (w = 0, lw = whereConditions.length; w < lw; w++) {\r\n\t                    assert = fc(item, whereConditions[w].realConditions);\r\n\t                    if (assert) {\r\n\t                        if (justFirst) {\r\n\t                            return (justIndexes) ? l : item;\r\n\t                        }\r\n\t                        result.push((justIndexes) ? l : item);\r\n\t                        break;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        if (justFirst) {\r\n\t            //Because in the loops, any positive evaluation makes a return.\r\n\t            //At this point there was no matches.\r\n\t            return undefined;\r\n\t        }\r\n\t\r\n\t        return result;\r\n\t    },\r\n\t    // The following function is a copy of the of the value_equals utiliy of\r\n\t    // the toubkal project.\r\n\t    // https://github.com/detky/toubkal/blob/master/lib/util/value_equals.js\r\n\t    equals: function (a, b, enforce_properties_order, cyclic) {\r\n\t        /* -----------------------------------------------------------------------------------------\r\n\t         equals( a, b [, enforce_properties_order, cyclic] )\r\n\t\r\n\t         Returns true if a and b are deeply equal, false otherwise.\r\n\t\r\n\t         Parameters:\r\n\t         - a (Any type): value to compare to b\r\n\t         - b (Any type): value compared to a\r\n\t\r\n\t         Optional Parameters:\r\n\t         - enforce_properties_order (Boolean): true to check if Object properties are provided\r\n\t         in the same order between a and b\r\n\t\r\n\t         - cyclic (Boolean): true to check for cycles in cyclic objects\r\n\t\r\n\t         Implementation:\r\n\t         'a' is considered equal to 'b' if all scalar values in a and b are strictly equal as\r\n\t         compared with operator '===' except for these two special cases:\r\n\t         - 0 === -0 but are not equal.\r\n\t         - NaN is not === to itself but is equal.\r\n\t\r\n\t         RegExp objects are considered equal if they have the same lastIndex, i.e. both regular\r\n\t         expressions have matched the same number of times.\r\n\t\r\n\t         Functions must be identical, so that they have the same closure context.\r\n\t\r\n\t         \"undefined\" is a valid value, including in Objects\r\n\t\r\n\t         106 automated tests.\r\n\t\r\n\t         Provide options for slower, less-common use cases:\r\n\t\r\n\t         - Unless enforce_properties_order is true, if 'a' and 'b' are non-Array Objects, the\r\n\t         order of occurence of their attributes is considered irrelevant:\r\n\t         { a: 1, b: 2 } is considered equal to { b: 2, a: 1 }\r\n\t\r\n\t         - Unless cyclic is true, Cyclic objects will throw:\r\n\t         RangeError: Maximum call stack size exceeded\r\n\t         */\r\n\t        return a === b       /* strick equality should be enough unless zero*/ // jshint ignore:line\r\n\t            && a !== 0         /* because 0 === -0, requires test by _equals()*/   // jshint ignore:line\r\n\t            || _equals(a, b) /* handles not strictly equal or zero values*/   // jshint ignore:line\r\n\t            ;\r\n\t        function _equals(a, b) {\r\n\t            // a and b have already failed test for strict equality or are zero\r\n\t\r\n\t            var s, l, p, x, y;\r\n\t\r\n\t            // They should have the same toString() signature\r\n\t            if ((s = toString.call(a)) !== toString.call(b)) return false; // jshint ignore:line\r\n\t\r\n\t            switch (s) {\r\n\t                default: // Boolean, Date, String\r\n\t                    return a.valueOf() === b.valueOf();\r\n\t\r\n\t                case '[object Number]':\r\n\t                    // Converts Number instances into primitive values\r\n\t                    // This is required also for NaN test bellow\r\n\t                    a = +a;\r\n\t                    b = +b;\r\n\t\r\n\t                    return a ?         // a is Non-zero and Non-NaN\r\n\t                        a === b\r\n\t                        :                // a is 0, -0 or NaN\r\n\t                        a === a ?      // a is 0 or -O\r\n\t                            1 / a === 1 / b    // 1/0 !== 1/-0 because Infinity !== -Infinity\r\n\t                            : b !== b        // NaN, the only Number not equal to itself!\r\n\t                        ;\r\n\t                // [object Number]\r\n\t\r\n\t                case '[object RegExp]':\r\n\t                    return a.source == b.source // jshint ignore:line\r\n\t                        && a.global == b.global // jshint ignore:line\r\n\t                        && a.ignoreCase == b.ignoreCase // jshint ignore:line\r\n\t                        && a.multiline == b.multiline // jshint ignore:line\r\n\t                        && a.lastIndex == b.lastIndex // jshint ignore:line\r\n\t                        ;\r\n\t                // [object RegExp]\r\n\t\r\n\t                case '[object Function]':\r\n\t                    return false; // functions should be strictly equal because of closure context\r\n\t                // [object Function]\r\n\t\r\n\t                case '[object Array]':\r\n\t                    // intentionally duplicated bellow for [object Object]\r\n\t                    if (cyclic && (x = reference_equals(a, b)) !== null) return x;  // jshint ignore:line\r\n\t\r\n\t                    if ((l = a.length) != b.length) return false; // jshint ignore:line\r\n\t                    // Both have as many elements\r\n\t\r\n\t                    while (l--) {\r\n\t                        if ((x = a[l]) === (y = b[l]) && x !== 0 || _equals(x, y)) continue; // jshint ignore:line\r\n\t\r\n\t                        return false;\r\n\t                    }\r\n\t\r\n\t                    return true;\r\n\t                // [object Array]\r\n\t\r\n\t                case '[object Object]':\r\n\t                    // intentionally duplicated from above for [object Array]\r\n\t                    if (cyclic && (x = reference_equals(a, b)) !== null) return x; // jshint ignore:line\r\n\t\r\n\t                    l = 0; // counter of own properties\r\n\t\r\n\t                    if (enforce_properties_order) {\r\n\t                        var properties = [];\r\n\t\r\n\t                        for (p in a) {\r\n\t                            if (a.hasOwnProperty(p)) {\r\n\t                                properties.push(p);\r\n\t\r\n\t                                if ((x = a[p]) === (y = b[p]) && x !== 0 || _equals(x, y)) continue; // jshint ignore:line\r\n\t\r\n\t                                return false;\r\n\t                            }\r\n\t                        }\r\n\t\r\n\t                        // Check if 'b' has as the same properties as 'a' in the same order\r\n\t                        for (p in b)\r\n\t                            if (b.hasOwnProperty(p) && properties[l++] != p) // jshint ignore:line\r\n\t                                return false; // jshint ignore:line\r\n\t                    } else {\r\n\t                        for (p in a) {\r\n\t                            if (a.hasOwnProperty(p)) {\r\n\t                                ++l;\r\n\t\r\n\t                                if ((x = a[p]) === (y = b[p]) && x !== 0 || _equals(x, y)) continue; // jshint ignore:line\r\n\t\r\n\t                                return false;\r\n\t                            }\r\n\t                        }\r\n\t\r\n\t                        // Check if 'b' has as not more own properties than 'a'\r\n\t                        for (p in b)\r\n\t                            if (b.hasOwnProperty(p) && --l < 0) // jshint ignore:line\r\n\t                                return false; // jshint ignore:line\r\n\t                    }\r\n\t\r\n\t                    return true;\r\n\t                // [object Object]\r\n\t            } // switch toString.call( a )\r\n\t        } // _equals()\r\n\t\r\n\t        /* -----------------------------------------------------------------------------------------\r\n\t         reference_equals( a, b )\r\n\t\r\n\t         Helper function to compare object references on cyclic objects or arrays.\r\n\t\r\n\t         Returns:\r\n\t         - null if a or b is not part of a cycle, adding them to object_references array\r\n\t         - true: same cycle found for a and b\r\n\t         - false: different cycle found for a and b\r\n\t\r\n\t         On the first call of a specific invocation of equal(), replaces self with inner function\r\n\t         holding object_references array object in closure context.\r\n\t\r\n\t         This allows to create a context only if and when an invocation of equal() compares\r\n\t         objects or arrays.\r\n\t         */\r\n\t        function reference_equals(a, b) {\r\n\t            var object_references = [];\r\n\t\r\n\t            return (reference_equals = _reference_equals)(a, b); // jshint ignore:line\r\n\t\r\n\t            function _reference_equals(a, b) {\r\n\t                var l = object_references.length;\r\n\t\r\n\t                while (l--)\r\n\t                    if (object_references[l--] === b) // jshint ignore:line\r\n\t                        return object_references[l] === a; // jshint ignore:line\r\n\t\r\n\t                object_references.push(a, b);\r\n\t\r\n\t                return null;\r\n\t            } // _reference_equals()\r\n\t        } // reference_equals()\r\n\t    } // equals()\r\n\t};\r\n\t\r\n\t\r\n\tmainContainer.pa.auxiliaryFunctions = {\r\n\t    Contains: function (value, enforcePropsOrder, cyclic) {\r\n\t        return function (val) {\r\n\t            if (!val.paIsArray) {\r\n\t                throw new Error(\"PowerArray error => parameter val passed to Contains function should be an array.\");\r\n\t            }\r\n\t            var l = val.length, isIndexable = false;\r\n\t            var typeToEvaluate = typeof value;\r\n\t\r\n\t            switch (typeToEvaluate) {\r\n\t                case \"number\":\r\n\t                case \"string\":\r\n\t                case \"boolean\":\r\n\t                    isIndexable = true;\r\n\t                    break;\r\n\t                default: //anything else\r\n\t                    //duck type to exclude dates\r\n\t                    if (typeof value.getMonth === 'function') {\r\n\t                        isIndexable = true;\r\n\t                        break;\r\n\t                    }\r\n\t                    isIndexable = false;\r\n\t                    break;\r\n\t            }\r\n\t            if (isIndexable) {\r\n\t                return val.indexOf(value) > -1;\r\n\t            }\r\n\t\r\n\t            while (l--) {\r\n\t                if (pa.paWhereHelper.equals(val[l], value, enforcePropsOrder, cyclic)) {\r\n\t                    return true;\r\n\t                }\r\n\t            }\r\n\t            return false;\r\n\t\r\n\t        };\r\n\t    },\r\n\t    Between: function (from, to, excludeExactMatches) {\r\n\t        if (to < from) {\r\n\t            console.warn(\"PowerArray warn => Parameters 'from' and 'to' passed to function Between() makes no sense: Parameter 'to' (\" + to + \") should be greater than from (\" + from + \")\");\r\n\t        }\r\n\t        if (!excludeExactMatches) {\r\n\t            return function (val) {\r\n\t                return val >= from && val <= to;\r\n\t            };\r\n\t        } else {\r\n\t            return function (val) {\r\n\t                return val > from && val < to;\r\n\t            };\r\n\t        }\r\n\t    },\r\n\t    EndsWith: function (value) {\r\n\t        var value2 = value + '';\r\n\t        return function (endsWithString) {\r\n\t\r\n\t            endsWithString = endsWithString + '';\r\n\t            return endsWithString.substr(endsWithString.length - (value2).length) === value2;\r\n\t        };\r\n\t    },\r\n\t    StartsWith: function (value) {\r\n\t        var value2 = value + '';\r\n\t        return function (val) {\r\n\t            val = val + '';\r\n\t            return val.indexOf(value2) === 0;\r\n\t        };\r\n\t    },\r\n\t    GreaterOrEqualThan: function (value) {\r\n\t        return function (val) {\r\n\t            return val >= value;\r\n\t        };\r\n\t    },\r\n\t    GreaterThan: function (value) {\r\n\t        return function (val) {\r\n\t            return val > value;\r\n\t        };\r\n\t    },\r\n\t    SmallerOrEqualThan: function (value) {\r\n\t        return function (val) {\r\n\t            return val <= value;\r\n\t        };\r\n\t    },\r\n\t    SmallerThan: function (value) {\r\n\t        return function (val) {\r\n\t            return val < value;\r\n\t        };\r\n\t    },\r\n\t    EqualTo3: function (value) {\r\n\t        return function (val) {\r\n\t            return val === value;\r\n\t        };\r\n\t    },\r\n\t    NotEqualTo3: function (value) {\r\n\t        return function (val) {\r\n\t            return val !== value;\r\n\t        };\r\n\t    },\r\n\t    EqualTo2: function (value) {\r\n\t        return function (val) {\r\n\t            // ReSharper disable once CoercedEqualsUsing\r\n\t            return val == value; // jshint ignore:line\r\n\t        };\r\n\t    },\r\n\t    NotEqualTo2: function (value) {\r\n\t        return function (val) {\r\n\t            // ReSharper disable once CoercedEqualsUsing\r\n\t            return val != value; // jshint ignore:line\r\n\t        };\r\n\t    },\r\n\t    IsUndefined: function () {\r\n\t        return function (val) {\r\n\t            return val === undefined;\r\n\t        };\r\n\t    },\r\n\t    IsDefined: function () {\r\n\t        return function (val) {\r\n\t            return val !== undefined;\r\n\t        };\r\n\t    },\r\n\t    In: function (list) {\r\n\t        //TODO: investigar si esta function pierde performance al no estar devolviendo una\r\n\t        //funcion como todo el resto.\r\n\t\r\n\t        if (arguments.length > 1) {\r\n\t            list = Array.prototype.slice.call(arguments);\r\n\t        }\r\n\t        return function (val) {\r\n\t            return list.indexOf(val) !== -1; // jshint ignore:line\r\n\t        };\r\n\t    },\r\n\t    NotIn: function (list) {\r\n\t        if (arguments.length > 1) {\r\n\t            list = Array.prototype.slice.call(arguments);\r\n\t        }\r\n\t        return function (val) {\r\n\t            return list.indexOf(val) === -1; // jshint ignore:line\r\n\t        };\r\n\t    },\r\n\t    EqualTo: function (object, func, enforcePropsOrder, cyclic) {\r\n\t        return function (val) {\r\n\t            if (func) {\r\n\t                return func(val, object);\r\n\t            } else {\r\n\t                return pa.paWhereHelper.equals(object, val, enforcePropsOrder, cyclic);\r\n\t            }\r\n\t        };\r\n\t    },\r\n\t    Like: function (value) {\r\n\t        if (!value.paIsArray) {\r\n\t            value = Array.prototype.slice.call(arguments);\r\n\t        }\r\n\t        return function (val) {\r\n\t            var l = value.length;\r\n\t            while (l--) {\r\n\t                if (val.indexOf(value[l]) === -1) {\r\n\t                    return false;\r\n\t                }\r\n\t            }\r\n\t            return true;\r\n\t        };\r\n\t    },\r\n\t    NotLike: function (value) {\r\n\t        if (!value.paIsArray) {\r\n\t            value = Array.prototype.slice.call(arguments);\r\n\t        }\r\n\t        return function (val) {\r\n\t            var l = value.length;\r\n\t            while (l--) {\r\n\t                if (val.indexOf(value[l]) > -1) {\r\n\t                    return false;\r\n\t                }\r\n\t            }\r\n\t            return true;\r\n\t        };\r\n\t    },\r\n\t    LikeIgnoreCase: function (value) {\r\n\t        var valueCaseInsensitive = '';\r\n\t        if (!value.paIsArray) {\r\n\t            value = Array.prototype.slice.call(arguments);\r\n\t        }\r\n\t        return function (val) {\r\n\t            var l = value.length;\r\n\t            while (l--) {\r\n\t                valueCaseInsensitive = value[l].toUpperCase();\r\n\t                if (val.toUpperCase().indexOf(valueCaseInsensitive) === -1) {\r\n\t                    return false;\r\n\t                }\r\n\t            }\r\n\t            return true;\r\n\t        };\r\n\t    },\r\n\t    NotLikeIgnoreCase: function (value) {\r\n\t        var valueCaseInsensitive = '';\r\n\t        if (!value.paIsArray) {\r\n\t            value = Array.prototype.slice.call(arguments);\r\n\t        }\r\n\t        return function (val) {\r\n\t            var l = value.length;\r\n\t            while (l--) {\r\n\t                valueCaseInsensitive = value[l].toUpperCase();\r\n\t                if (val.toUpperCase().indexOf(valueCaseInsensitive) > -1) {\r\n\t                    return false;\r\n\t                }\r\n\t            }\r\n\t            return true;\r\n\t        };\r\n\t    },\r\n\t    IsTruthy: function () {\r\n\t        return function (val) {\r\n\t            return (val) ? true : false;\r\n\t        };\r\n\t    },\r\n\t    IsFalsy: function () {\r\n\t        return function (val) {\r\n\t            return (val) ? false : true;\r\n\t        }\r\n\t    },\r\n\t    IsTrue: function () {\r\n\t        return function (val) {\r\n\t            return val === true;\r\n\t        };\r\n\t    },\r\n\t    IsFalse: function () {\r\n\t        return function (val) {\r\n\t            return val === false;\r\n\t        }\r\n\t    },\r\n\t    IsEmpty: function () {\r\n\t        return function (val) {\r\n\t            return val === undefined || val === '' || val === null || val === 0 || (val.paIsArray && val.length === 0);\r\n\t        }\r\n\t    },\r\n\t    IsNotEmpty: function () {\r\n\t        return function (val) {\r\n\t            if (val === undefined || val === null) {\r\n\t                return false;\r\n\t            }\r\n\t            return (val + \"\").length > 0;\r\n\t        }\r\n\t    },\r\n\t    IsNull: function () {\r\n\t        return function (val) {\r\n\t            return val === null;\r\n\t        }\r\n\t    },\r\n\t    IsNotNull: function () {\r\n\t        return function (val) {\r\n\t            return val !== null;\r\n\t        }\r\n\t    },\r\n\t    IsNaN: function () {\r\n\t        return function (val) {\r\n\t            return isNaN(val);\r\n\t        }\r\n\t    },\r\n\t    IsNotNaN: function () {\r\n\t        return function (val) {\r\n\t            return !isNaN(val);\r\n\t        }\r\n\t    },\r\n\t    IsNumeric: function (num) {\r\n\t        return !isNaN(parseFloat(num)) && isFinite(num);\r\n\t    },\r\n\t    IsInteger: function (num) {\r\n\t        return num === parseInt(num, 10);\r\n\t    }\r\n\t\r\n\t};\r\n\t\r\n\tmainContainer.pa.prototypedFunctions_Array = {\r\n\t    getIndexByProperty: function (valueToSearchFor) {// jshint ignore:line\r\n\t        /**\r\n\t         * This function, evaluates properties (or function results) over each object on an array, and answers with an\r\n\t         * array of the found elements that matches the specified condition. The condition is given by the parameters\r\n\t         * provided after position 2. The only fixed parameters are the objects array and the value to search for.\r\n\t         * You can provide so many parameters as you want. Each parameter means one level deeper to search for. For example:\r\n\t         *\r\n\t         *      let's say that you have a collection of \"car\" objects, having each car a function called \"getPassengers\"\r\n\t         *      which answers with a collection of \"people\" objects, and each people have a property called \"name\".\r\n\t         *\r\n\t         *  To get an array of cars having a passenger called Paul, use as following:\r\n\t         *\r\n\t         *  var namedPaul = findDistinctValuesOnObjectCollectionByProperty(theCarsCollection, 'Paul', 'getPassengers()','name');\r\n\t         *\r\n\t         * @param objectsArray\r\n\t         * @param valueToSearchFor\r\n\t         * @returns {number}\r\n\t         */\r\n\t        var objectsArray = this;\r\n\t        //if (!objectsArray) {\r\n\t        //    return -1;\r\n\t        //}\r\n\t        var ia, la = arguments.length; // ia = i for arguments; la = length for arguments\r\n\t        var io, lo = objectsArray.length; // io = i for objects; lo = length for objects\r\n\t\r\n\t        for (io = 0; io < lo; io++) { //iterate objects array\r\n\t            var tmpObj = objectsArray[io];\r\n\t\r\n\t            for (ia = 1; ia < la; ia++) { //iterate throw arguments to get the right property. Start from 1, to exclude the objectsArray self\r\n\t                var arg = arguments[ia];\r\n\t                var isFunc = arg.substring(arg.length - 2) === \"()\";\r\n\t                var argName = (isFunc) ? arg.substr(0, arg.length - 2) : arg;\r\n\t                tmpObj = (isFunc) ? tmpObj[argName]() : tmpObj[arg];\r\n\t                // Converting comparison needed (e.g. string id vs integer id)\r\n\t                // ReSharper disable once CoercedEqualsUsing\r\n\t                if (ia + 1 === la && tmpObj == valueToSearchFor) { // jshint ignore:line\r\n\t                    return io;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        return -1;\r\n\t    },\r\n\t    GetPropertyFlat: function (property, keepOrder, includeDuplicates, includeUndefineds) { // jshint ignore:line\r\n\t        var array = this;\r\n\t        var result = [], t = array.length;\r\n\t        if (keepOrder === true) {\r\n\t            for (var i = 0; i < t; i++) {\r\n\t                if (includeDuplicates || result.indexOf(array[i][property]) === -1) {\r\n\t                    if (includeUndefineds === true || array[i][property] !== undefined) {\r\n\t                        result.push(array[i][property]);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        } else {\r\n\t            while (t--) {\r\n\t                if (includeDuplicates || result.indexOf(array[t][property]) === -1) {\r\n\t                    if (includeUndefineds === true || array[t][property] !== undefined) {\r\n\t                        result.push(array[t][property]);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        return result;\r\n\t    },\r\n\t    GetByProperty: function (valueToSearchFor) {// jshint ignore:line\r\n\t        /**\r\n\t         * This function, evaluates properties (or function results) over each object on an array, and answers with an\r\n\t         * array of the found elements that matches the specified condition. The condition is given by the parameters\r\n\t         * provided after position 2. The only fixed parameters are the objects array and the value to search for.\r\n\t         * You can provide so many parameters as you want. Each parameter means one level deeper to search for. For example:\r\n\t         *\r\n\t         *      let's say that you have a collection of \"car\" objects, having each car a function called \"getPassengers\"\r\n\t         *      which answers with a collection of \"people\" objects, and each people have a property called \"name\".\r\n\t         *\r\n\t         *  To get an array of cars having a passenger called Paul, use as following:\r\n\t         *\r\n\t         *  var passengersNamedPaul = carsArray.getByProperty('Paul', 'getPassengers()','name');\r\n\t         *\r\n\t         * @param objectsArray\r\n\t         * @param valueToSearchFor\r\n\t         * @returns {Array}\r\n\t         */\r\n\t        var objectsArray = this;\r\n\t        var results = [];\r\n\t        var ia, la = arguments.length; // ia = i for arguments; la = length for arguments\r\n\t        var io, lo = objectsArray.length; // io = i for objects; lo = length for objects\r\n\t        for (io = 0; io < lo; io++) { //iterate objects array\r\n\t            var tmpObj = objectsArray[io];\r\n\t\r\n\t            for (ia = 1; ia < la; ia++) { //iterate throw arguments to get the right property. Start from 1, to exclude the objectsArray self\r\n\t                var arg = arguments[ia];\r\n\t                var isFunc = arg.substring(arg.length - 2) === \"()\";\r\n\t                var argName = (isFunc) ? arg.substr(0, arg.length - 2) : arg;\r\n\t                tmpObj = (isFunc) ? tmpObj[argName]() : tmpObj[arg];\r\n\t                if (ia + 1 === la && tmpObj === valueToSearchFor) {\r\n\t                    results.push(objectsArray[io]);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        return results;\r\n\t    },\r\n\t    /**\r\n\t     * Executes a function (task) on each element of the array (this).\r\n\t     * @param {} task       A function to execute. It will receive 3 parameters:\r\n\t     *                          1) one array item\r\n\t     *                          2) index of the passed item (param 1) on the original array.\r\n\t     *                          3) the complete array. Warning, you should not change it. See it as read-only!\r\n\t     *\r\n\t     * @param {} callback   A callback function to be executed after processing all array items.\r\n\t     *                      It will get as first parameter the results-array (that lately will be\r\n\t     *                      returned as result of this function).\r\n\t     *                       *****************************PLEASE READ**********************************\r\n\t     *                      *** If the callback function returns something different than undefined, ***\r\n\t     *                      ***      the results-array will be replaced with that return value       ***\r\n\t     *                       **************************************************************************\r\n\t     * @param {} keepOrder\r\n\t     * @returns             array of the result of each executed task (keeping same position as on original\r\n\t     *                      array, regardless order). Excepion: when the execution of the callback function\r\n\t     *                      returns something different than undefined, that will be returned instead of the\r\n\t     *                      . If not,\r\n\t     */\r\n\t    RunEach: function (task, callback, keepOrder, progress) {// jshint ignore:line\r\n\t        var l = this.length, i = 0, result = new Array(this.length), tmp;\r\n\t        if (!keepOrder) {\r\n\t            while (l--) {\r\n\t                result[l] = task(this[l], l, this);\r\n\t            }\r\n\t        } else {\r\n\t            for (; i < l; i++) {\r\n\t                result[i] = task(this[i], i, this);\r\n\t            }\r\n\t        }\r\n\t        if (callback) {\r\n\t            //if the callback function returns something,\r\n\t            //the result will be overrided with that result.\r\n\t            result = callback(result) || result;\r\n\t        }\r\n\t        return result;\r\n\t    },\r\n\t    Sort: function (sortConditions) { // jshint ignore:line\r\n\t        var realConditions = [];\r\n\t        var conditionType = typeof sortConditions;\r\n\t\r\n\t        switch (conditionType) {\r\n\t            case \"string\":\r\n\t                //This call, with a first parameter of type string, should be \"ASC\" or \"DESC\"\r\n\t                var condition = sortConditions.toUpperCase();\r\n\t                switch (condition) {\r\n\t                    case pa.Sort.Ascending:\r\n\t                    case pa.Sort.Asc:\r\n\t                        return this.sort(function (a, b) {\r\n\t                            if (a < b) {\r\n\t                                return -1;\r\n\t                            } else if (a > b) {\r\n\t                                return 1;\r\n\t                            }\r\n\t                            return 0;\r\n\t                        });\r\n\t                    case pa.Sort.AscendingIgnoringCase:\r\n\t                    case pa.Sort.AscIgnoringCase:\r\n\t                        return this.sort(function (a, b) {\r\n\t                            try {\r\n\t                                return a.toLowerCase().localeCompare(b.toLowerCase());\r\n\t                            } catch (e) {\r\n\t                                if (console && console.warn) {\r\n\t                                    console.warn('PowerArray => Error trying to sort by ' + condition + '. When sorting by ' + condition + ', all values has to be strings. Probably it\\'s not the case!. Now casting to string, performance may be affected.');\r\n\t                                    a = a + '';\r\n\t                                    b = b + '';\r\n\t                                    return a.toLowerCase().localeCompare(b.toLowerCase());\r\n\t                                }\r\n\t                            }\r\n\t                        });\r\n\t                    case pa.Sort.Descending:\r\n\t                    case pa.Sort.Desc:\r\n\t                        return this.sort(function (a, b) {\r\n\t                            if (a > b) {\r\n\t                                return -1;\r\n\t                            } else if (a < b) {\r\n\t                                return 1;\r\n\t                            }\r\n\t                            return 0;\r\n\t                        });\r\n\t                    case pa.Sort.DescendingIgnoringCase:\r\n\t                    case pa.Sort.DescIgnoringCase:\r\n\t                        return this.sort(function (a, b) {\r\n\t                            return (a.toLowerCase().localeCompare(b.toLowerCase())) * -1;\r\n\t                        });\r\n\t                    default:\r\n\t                        throw new Error(\"PowerArray Error: Invalid sort condition. If you pass a first parameter of type String to the Sort function,\" +\r\n\t                            \" PowerArray assumes that you have a simple array on your hand (one dimension of primitives). Possible parameter values for function Sort \" +\r\n\t                            \" in that situation, are: 1) To sort Ascending: 'Asc' and 'AscIgnoreCase' (aliases: 'Ascending', 'AscendingIgnoreCase'), and 2)\" +\r\n\t                            \" To sort Descending: 'Desc','Descending' (aliases: 'Descending', 'DescendingIgnoreCase') \");\r\n\t                }\r\n\t                break;\r\n\t            case \"object\":\r\n\t\r\n\t                if (sortConditions instanceof RegExp) {\r\n\t                    throw new Error(\"PowerArray Error: Invalid sortConditions object. A RegExp is not allowed as Sort Criterion!\");\r\n\t                }\r\n\t\r\n\t                if (!sortConditions) {\r\n\t                    if (sortConditions.hasOwnProperty('length')) {\r\n\t                        throw new Error(\"PowerArray Error: Invalid sortConditions object\");\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                for (var property in sortConditions) {\r\n\t                    if (sortConditions.hasOwnProperty(property)) {\r\n\t\r\n\t                        //transform the keys into a better object with properties Column and SortOrder\r\n\t                        var value = sortConditions[property].toUpperCase();\r\n\t\r\n\t                        if (!mainContainer.pa.Sort._validSortConfigStrings.indexOf(sortConditions[property]) === -1) {\r\n\t                            throw new Error(\"PowerArray Configuration Error => Invalid sort direction for property \" + property + \": '\" + sortConditions[property] + \"'\");\r\n\t                        }\r\n\t\r\n\t                        realConditions.push({\r\n\t                            column: property,\r\n\t                            sortDirection: value\r\n\t                        });\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                return this.sort(function (a, b) {\r\n\t                    var result = 0, currentColumn, cycleValue;\r\n\t                    for (var i = 0, l = realConditions.length; i < l; i++) {\r\n\t                        cycleValue = 10 - i;\r\n\t                        currentColumn = realConditions[i].column;\r\n\t                        switch (realConditions[i].sortDirection) {\r\n\t                            case mainContainer.pa.Sort.Ascending:\r\n\t                            case mainContainer.pa.Sort.Asc:\r\n\t                            case mainContainer.pa.Sort.AscendingIgnoringCase:\r\n\t                            case mainContainer.pa.Sort.AscIgnoringCase:\r\n\t                                if (a[currentColumn] < b[currentColumn]) {\r\n\t                                    result -= cycleValue;\r\n\t                                } else if (a[currentColumn] > b[currentColumn]) {\r\n\t                                    result += cycleValue;\r\n\t                                }\r\n\t                                break;\r\n\t                            case mainContainer.pa.Sort.Descending:\r\n\t                            case mainContainer.pa.Sort.Desc:\r\n\t                            case mainContainer.pa.Sort.DescendingIgnoringCase:\r\n\t                            case mainContainer.pa.Sort.DescIgnoringCase:\r\n\t                                if (a[currentColumn] < b[currentColumn]) {\r\n\t                                    result += cycleValue;\r\n\t                                } else if (a[currentColumn] > b[currentColumn]) {\r\n\t                                    result -= cycleValue;\r\n\t                                }\r\n\t                                break;\r\n\t                        }\r\n\t                    }\r\n\t                    return result;\r\n\t                });\r\n\t            case \"undefined\":\r\n\t                //No parameters passed, sorting by default\r\n\t                return this.sort();\r\n\t            case \"function\":\r\n\t                return this.sort(sortConditions); //simple forward to array.sort\r\n\t            default:\r\n\t                throw new Error(\"Unknown sortConditions object type (\" + conditionType + \")\");\r\n\t        }\r\n\t    },\r\n\t    Exists: function (whereConditions) {\r\n\t        if (pa.prototypedFunctions_Array.First.call(this, whereConditions)) {\r\n\t            return true;\r\n\t        } else {\r\n\t            return false;\r\n\t        }\r\n\t    },\r\n\t    Remove: function (whereConditions) {\r\n\t        var first = this.FirstIndex(whereConditions);\r\n\t        while (first !== undefined) {\r\n\t            this.splice(first, 1);\r\n\t            first = this.FirstIndex(whereConditions);\r\n\t        }\r\n\t        return this;\r\n\t    },\r\n\t    //this primitive distinct version works only for array of primitives.\r\n\t    Distinct: function () {\r\n\t        var val, l = this.length, results = [];\r\n\t        if (pa.utils.GetTypeOf(this) !== pa.utils.DataTypes.ArrayOfPrimitives) {\r\n\t            throw new Error(\"PowerArray => Distinct => Currently, the distinct function works only for arrays of primitive data.\");\r\n\t        }\r\n\t        while (l--) {\r\n\t            val = this[l];\r\n\t            if (results.indexOf(val) === -1 && val !== undefined) {\r\n\t                results.push(val);\r\n\t            }\r\n\t        }\r\n\t        return results;\r\n\t    },\r\n\t    /** Iterates an array and executes the function on each item as runeach does, but always returns the original array  */\r\n\t    Iterate: function(func, keepOrder){\r\n\t        this.RunEach(func, undefined, keepOrder);\r\n\t        return this;\r\n\t    },\r\n\t    /**returns a collection of the results of the execution of \"func\" in a given order */\r\n\t    Collect: function(func, keepOrder) {\r\n\t        return this.RunEach(func, undefined, keepOrder);\r\n\t    },\r\n\t    WhereIndexes: function (whereConditions, keepOrder, justFirst) {\r\n\t        return this.Where(whereConditions, keepOrder, justFirst, true);\r\n\t    },\r\n\t    Where: function (whereConditions, keepOrder, justFirst, justIndexes) {// jshint ignore:line\r\n\t        var i, l = this.length, item, result = [], tmp;\r\n\t        justIndexes = (justIndexes) ? true : false; //just to avoid casting when comparing during loop\r\n\t        if (typeof whereConditions === 'object' && !(whereConditions.paIsArray)) {\r\n\t            //If It's an object, but not an array, it is a conditions object\r\n\t            result = pa.paWhereHelper.ProcessConditionObject.call(this, whereConditions, keepOrder, false, justFirst, justIndexes);\r\n\t        } else {\r\n\t\r\n\t            //At this point, whereConditions could be a:\r\n\t            //                                          => function (a custom function),\r\n\t            //                                          => an pa.EqualTo,\r\n\t            //                                          => an Array of condition-objects\r\n\t\r\n\t            if (typeof whereConditions === 'undefined') {\r\n\t                var a = new Error(\"PowerArray => Where function => No condition object provided to function 'Where(whereConditions, keepOrder)'\");\r\n\t                a.message = \"InvalidWhereCondition\";\r\n\t                throw a;\r\n\t            } else if (whereConditions.paIsArray) {\r\n\t                //It's a conditions array\r\n\t                tmp = pa.paWhereHelper.ProcessConditionObject.call(this, whereConditions, keepOrder, true, justFirst, justIndexes);\r\n\t                if (justFirst)\r\n\t                    return tmp;\r\n\t                result.push.apply(result, tmp);\r\n\t            } else {\r\n\t                //whereConditions it's a function. It could be a custom function on the pa standard EqualTo (that works\r\n\t                //different than any other standard function)\r\n\t                if (keepOrder) {\r\n\t                    for (i = 0; i < l; i++) {\r\n\t                        item = this[i];\r\n\t                        if (whereConditions(item)) {\r\n\t                            if (justFirst) {\r\n\t                                return (justIndexes) ? i : item;\r\n\t                            }\r\n\t                            result.push(item);\r\n\t                        }\r\n\t                    }\r\n\t                } else {\r\n\t                    while (l--) {\r\n\t                        item = this[l];\r\n\t                        if (whereConditions(item)) {\r\n\t                            if (justFirst) {\r\n\t                                return (justIndexes) ? l : item;\r\n\t                            }\r\n\t                            result.push(item);\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        return result;\r\n\t    },\r\n\t    Count: function (whereConditions) {\r\n\t        if (arguments.length !== 1) {\r\n\t            throw new Error('PowerArray => Count function => Invalid arguments. The only argument is a whereCondition or an array of whereConditions object.');\r\n\t        }\r\n\t        return pa.prototypedFunctions_Array.Where.call(this, whereConditions, false, false).length;\r\n\t    },\r\n\t    First: function (whereConditions) {// jshint ignore:line\r\n\t        if (arguments.length === 0) {\r\n\t            return (this.length > 0) ? this[0] : undefined;\r\n\t        }\r\n\t        return pa.prototypedFunctions_Array.Where.call(this, whereConditions, true, true);\r\n\t    },\r\n\t    FirstIndex: function (whereConditions) {// jshint ignore:line\r\n\t        if (arguments.length === 0) {\r\n\t            return (this.length > 0) ? 0 : undefined;\r\n\t        }\r\n\t        return pa.prototypedFunctions_Array.Where.call(this, whereConditions, true, true, true);\r\n\t    },\r\n\t    Average: function () {\r\n\t        //TODO: the same way to work as Max()\r\n\t    },\r\n\t    /*Return an object containing min and max values of one or more propeties in an objects array */\r\n\t    Bounds: function () {\r\n\t        var l = this.length, alc, al = arguments.length, maxVal, result = {}, arrayItemValue, currentArgName = '';\r\n\t        if (al === 0) {\r\n\t            throw new Error(\"PowerArray => bounds => invalid params, please provide one or more target parameters\");\r\n\t        }\r\n\t        alc = al;\r\n\t        while (alc--) {\r\n\t            currentArgName = arguments[alc];\r\n\t            result[currentArgName] = { min: undefined, max: undefined };\r\n\t        }\r\n\t        while (l--) {\r\n\t            alc = al;\r\n\t            while (alc--) {\r\n\t                currentArgName = arguments[alc];\r\n\t                arrayItemValue = this[l][currentArgName];\r\n\t                if (result[currentArgName].max === undefined || (arrayItemValue !== undefined && arrayItemValue > result[currentArgName].max)) {\r\n\t                    result[currentArgName].max = arrayItemValue;\r\n\t                }\r\n\t                if (result[currentArgName].min === undefined || (arrayItemValue !== undefined && arrayItemValue < result[currentArgName].min)) {\r\n\t                    result[currentArgName].min = arrayItemValue;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return result;\r\n\t\r\n\t    },\r\n\t    /**\r\n\t     * Return max values of specified properties\r\n\t     * @param {} target\r\n\t     * @returns {}\r\n\t     */\r\n\t    Max: function () {\r\n\t        var l = this.length, alc, al = arguments.length, maxVal, result = {}, arrayItemValue, currentArgName = '';\r\n\t        if (al === 0) {\r\n\t            throw new Error(\"PowerArray => Max => invalid params, please provide one or more target parameters\");\r\n\t        }\r\n\t        alc = al;\r\n\t        while (alc) {\r\n\t            //evaluate if the passed arguments are integers. this means that the collection has indexable objects (arrays or array like objects)\r\n\t\r\n\t        }\r\n\t        while (l--) {\r\n\t            alc = al;\r\n\t            while (alc--) {\r\n\t                currentArgName = arguments[alc];\r\n\t                arrayItemValue = this[l][currentArgName];\r\n\t                if (result[currentArgName] === undefined || (arrayItemValue !== undefined && arrayItemValue > result[currentArgName])) {\r\n\t                    result[currentArgName] = arrayItemValue;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        if (al === 1) { //if only one max is expected, just return it\r\n\t            return result[currentArgName];\r\n\t        } else if (al > 1) {\r\n\t\r\n\t        }\r\n\t    },\r\n\t    Take: function (count, skip) {\r\n\t        skip = skip || 0;\r\n\t        var i = 0 + skip, l = this.length, result = [], added = 0;\r\n\t        for (; i < l && added < count; i++) {\r\n\t            result.push(this[i]);\r\n\t            added++;\r\n\t        }\r\n\t        return result;\r\n\t    },\r\n\t    Last: function () {\r\n\t        var idx = this.length - 1;\r\n\t        return (idx > -1) ? this[idx] : null;\r\n\t    }\r\n\t};\r\n\t\r\n\t// ReSharper disable once WrongExpressionStatement\r\n\tmainContainer.pa.Sort = {\r\n\t    Ascending: 'ASCENDING',\r\n\t    Asc: 'ASC',\r\n\t    AscendingIgnoringCase: 'ASCENDINGIGNORINGCASE',\r\n\t    AscIgnoringCase: 'ASCIGNORINGCASE',\r\n\t    Descending: 'DESCENDING',\r\n\t    Desc: 'DESC',\r\n\t    DescendingIgnoringCase: 'DESCENDINGIGNORINGCASE',\r\n\t    DescIgnoringCase: 'DESCIGNORINGCASE',\r\n\t}\r\n\tif (mainContainer.Sort === undefined) {\r\n\t    mainContainer.Sort = mainContainer.Sort || mainContainer.pa.Sort;\r\n\t    mainContainer.pa.Sort._validSortConfigStrings = [\r\n\t        mainContainer.pa.Sort.Ascending,\r\n\t        mainContainer.pa.Sort.Asc,\r\n\t        mainContainer.pa.Sort.AscendingIgnoringCase,\r\n\t        mainContainer.pa.Sort.AscIgnoringCase,\r\n\t        mainContainer.pa.Sort.Descending,\r\n\t        mainContainer.pa.Sort.Desc,\r\n\t        mainContainer.pa.Sort.DescendingIgnoringCase,\r\n\t        mainContainer.pa.Sort.DescIgnoringCase];\r\n\t} else {\r\n\t    if(console && console.warn) console.warn('PowerArray warning! => prop \"Sort\" already exists on parent scope. You have to use \"pa.Sort\" instead of \"Sort\" on your code.\"');\r\n\t}\r\n\t\r\n\t\r\n\t//this is intended to help IDE'S to understand the working way of powerarray. This will never be executed!\r\n\tif (false) {\r\n\t    Array.prototype.Where = function (WhereConditions) {\r\n\t\t\r\n\t    };\r\n\t}\r\n\t\r\n\tvar paArray = function (array) {\r\n\t    if (!array.paIsArray) {\r\n\t        throw new Error('PowerArray => paArray warning => Invalid array passed to pa() function\"');\r\n\t    }\r\n\t    var newArray = array.slice(0);\r\n\t\r\n\t    var functionsToAttach = mainContainer.pa.prototypedFunctions_Array;\r\n\t    for (var currentFunctionName in functionsToAttach) {\r\n\t        if (functionsToAttach.hasOwnProperty(currentFunctionName)) {\r\n\t            newArray[currentFunctionName] = functionsToAttach[currentFunctionName]; // jshint ignore:line\r\n\t        }\r\n\t    }\r\n\t    return newArray;\r\n\t};\r\n\t\r\n\tpaArray.prototype.isArray = true;\r\n\t\r\n\t//region \"Initialization\"\r\n\t(function () {\r\n\t    //Register all Pa auxiliary functions to make them accessible through the mainContainer object and mainContainer.pa object\r\n\t    //If a mainContainer accessor is already taken and cannot be set, warn the user.\r\n\t    var obj = mainContainer.pa.auxiliaryFunctions;\r\n\t    for (var p in obj) {\r\n\t        if (obj.hasOwnProperty(p)) {\r\n\t            mainContainer.pa[p] = obj[p];\r\n\t            if (!mainContainer[p]) {\r\n\t                mainContainer[p] = obj[p];\r\n\t            } else {\r\n\t                console.warn('PowerArray warning! => property mainContainer.' + p + ' already exists. PowerArrayFunction pa.' + p + ' cannot register this function on mainContainer scope. However, you can still using it by calling \"pa.' + p + '\"');\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    if (!Array.prototype.paIsArray) {\r\n\t        //TODO: this cannot stay fix like that ;(\r\n\t        Array.prototype.paIsArray = true;// jshint ignore:line\r\n\t    }\r\n\t\r\n\t    //Register all Array prototype functions to make them accessible to each array.\r\n\t    //If function name is already is already taken, warn the user and describe alternative usage way.\r\n\t    var functionsToAttach = mainContainer.pa.prototypedFunctions_Array;\r\n\t    for (var currentFunctionName in functionsToAttach) {\r\n\t        if (functionsToAttach.hasOwnProperty(currentFunctionName)) {\r\n\t            if (Array.prototype.hasOwnProperty(currentFunctionName)) {\r\n\t                console.warn('PowerArray warning! => Array Prototype was modified by other library: the function name \"' + currentFunctionName +\r\n\t                    '\" is already in use. PowerArray will NOT override the prototype method. However, you can still using the function' + \r\n\t\t\t\t\t\t' by surrounding your array with a pa constructor call, as following: pa(yourArrayName).' + currentFunctionName + \"(...)\");\r\n\t            } else {\r\n\t                //function name is free, go on:\r\n\t                Array.prototype[currentFunctionName] = functionsToAttach[currentFunctionName]; // jshint ignore:line\r\n\t            }\r\n\t            // Attach all functions also to the paArray prototype, that is the wrapper for solve conflicts (pa(array))\r\n\t            // from array prototype\r\n\t            paArray.prototype[currentFunctionName] = functionsToAttach[currentFunctionName]; // jshint ignore:line\r\n\t        }\r\n\t    }\r\n\t})();\r\n\tif (isModule) {\r\n\t    module.exports = mainContainer.pa;\r\n\t}\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1);\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// PowerArray.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d4591b020b3c77f3cb2d","var mainContainer, module = module, isModule = false, isBrowser = true;\r\nif (typeof module !== \"undefined\") {\r\n    module.exports = {};\r\n    isModule = true;\r\n}\r\n\r\nif (typeof window === 'object') {\r\n    mainContainer = window;\r\n} else {\r\n    isBrowser = false;\r\n    mainContainer = global;\r\n}\r\nif(mainContainer.pa) {\r\n\tthrow new Error('PowerArray => Cannot load, global variable \"pa\" already exists. Loading twice?');\r\n}\r\nmainContainer.pa = function (object) {\r\n    if (object.constructor === Array || object.paIsArray) {\r\n        return new paArray(object);\r\n    } else {\r\n        //console.warn('PowerArray => The passed object is not natively an array. Trying to handle it as an array-like object...')\r\n        if ((mainContainer.ol !== undefined && ol.Collection) && object instanceof ol.Collection) {\r\n          //  console.log('Compatible openlayers object detected (ol.Collection)');\r\n            return paArray(object.getArray());\r\n        }\r\n        if (object.length === undefined) {\r\n            throw new Error('PowerArray => The passed object is not an array, or usable as such.');\r\n        }\r\n        return new paArray(object);\r\n    }\r\n};\r\n/*\r\nfunctions directly bound to the pa object:\r\n\r\n */\r\nmainContainer.pa.Range = function (from, to, step) {\r\n    if (!pa.IsNumeric(from)) {\r\n        throw new Error('PowerArray => Range fuction => The parameter \"from\" must be numeric. Wrong value is \"' + from + '\"');\r\n    }\r\n    if (!pa.IsNumeric(to)) {\r\n        throw new Error('PowerArray => Range fuction => The parameter \"to\" must be numeric. Received value is \"' + to + '\"');\r\n    }\r\n    if (!pa.IsNumeric(step)) {\r\n        throw new Error('PowerArray => Range fuction => The parameter \"step\" must be numeric. Received value is \"' + step + '\"');\r\n    }\r\n\r\n    from = parseFloat(from);\r\n    to = parseFloat(to);\r\n    step = parseFloat(step);\r\n\r\n    var result = [], i, l, currVal = from;\r\n    while (currVal < to) {\r\n        result.push(currVal);\r\n        currVal += step;\r\n    }\r\n    result.push(to);\r\n    return result;\r\n};\r\nmainContainer.pa.utils = {}\r\nmainContainer.pa.utils = {\r\n    DataTypes: {\r\n        String: 'String',\r\n        Number: 'Number',\r\n        Date: 'Date',\r\n        Boolean: 'Boolean',\r\n        Object: 'Object',\r\n        ArrayOfObjects: 'ArrayOfObjects',\r\n        ArrayOfPrimitives: 'ArrayOfPrimitives',\r\n        RegExp: 'RegExp',\r\n        Function: 'Function',\r\n        Null: 'Null',\r\n        Undefined: 'Undefined'\r\n    }, IsArrayOfObjects: function (val) {\r\n        var l;\r\n        if (!val.paIsArray || val.length === undefined) {\r\n            return false;\r\n        }\r\n        l = val.length;\r\n        while (l--) {\r\n            //TODO: this could fail in collections having objects but one undefined\r\n            if (pa.utils.GetTypeOf(val[l]) !== pa.utils.DataTypes.Object) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    /**\r\n     * Parses a string to boolean value. This function searches strictly for the strings \"true\", \"True\", \"trUE\", \"falsE\", etc.\r\n     * @param str the string to be evaluated\r\n     * @param throwIfNotMatch Boolean, if true, an exception will be raised if the string does not match. If false, null will be returned\r\n     * @returns {*} boolean value if string matches, null if not\r\n     */\r\n    parseBoolean: function (str, throwIfNotMatch) {\r\n        if (!pa.utils.isNullEmptyOrUndefined(str)) {\r\n            var strU = str.toUpperCase();\r\n            if (strU === \"TRUE\") {\r\n                return true;\r\n            }\r\n            if (strU === \"FALSE\") {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (throwIfNotMatch) {\r\n            throw new Error(\"The string passed to function parseBoolean (\" + str + \") doesn't match with any valid string\");\r\n        }\r\n\r\n        return null;\r\n    }, /**\r\n     * evaluate if a number or a string is undefined \"\" or null and return true or false\r\n     * @param what the element to evaluate\r\n     * @returns {boolean}\r\n     * @constructor\r\n     */\r\n    isNullEmptyOrUndefined: function (what) {\r\n        // null has to be evaluated before checking typeof\r\n        if (what === null) {\r\n            return true;\r\n        }\r\n        var t = typeof what;\r\n        if (t === \"boolean\") {\r\n            return false;\r\n        }\r\n\r\n        if (t !== \"number\" && t !== \"string\" && t !== \"undefined\") {\r\n            throw new Error(\"PowerArray => The function IsNullOrEmpty is designed to evaluate strings and numbers, but something different was provided (\" + t + \")\");\r\n        }\r\n\r\n        if (t === \"number\" && what === 0) {\r\n            return false;\r\n        }\r\n\r\n        if (!what) {\r\n            return true;\r\n        }\r\n        return (what + \"\").length === 0;\r\n    },\r\n    GetTypeOf: function (element, analyzeData) {\r\n\r\n        if (element === null) {\r\n            return pa.utils.DataTypes.Null;\r\n        }\r\n\r\n        if (element === undefined) {\r\n            return pa.utils.DataTypes.Undefined;\r\n        }\r\n        var to = typeof element;\r\n        switch (to) {\r\n            case 'string':\r\n                return pa.utils.DataTypes.String;\r\n            case 'function':\r\n                return pa.utils.DataTypes.Function;\r\n            case 'number':\r\n                return pa.utils.DataTypes.Number;\r\n            case 'boolean':\r\n                return pa.utils.DataTypes.Boolean;\r\n            case 'object':\r\n                //check hidden types\r\n                if (element instanceof String) {\r\n                    return pa.utils.DataTypes.String;\r\n                }\r\n\r\n                if (element instanceof Date) {\r\n                    return pa.utils.DataTypes.Date;\r\n                }\r\n\r\n                if (element instanceof Number) {\r\n                    return pa.utils.DataTypes.Number;\r\n                }\r\n\r\n                if (element instanceof RegExp) {\r\n                    return pa.utils.DataTypes.RegExp;\r\n                }\r\n                if (element.paIsArray) {\r\n                    // If its an array of objects, it has to be handled different,\r\n                    if (analyzeData && pa.utils.IsArrayOfObjects(element)) {\r\n                        return pa.utils.DataTypes.ArrayOfObjects;\r\n                    } else {\r\n                        return pa.utils.DataTypes.ArrayOfPrimitives;\r\n                    }\r\n                }\r\n                return pa.utils.DataTypes.Object;\r\n            default:\r\n                //any others\r\n                throw new Error(\"PowerArray Error : Unknown Datatype!\");\r\n        }\r\n    },\r\n    ArgumentsToArray: function (args, from, to) {\r\n        var i = from | 0, l = to || args.length, result = [];\r\n        for (; i < l; i++) {\r\n            result.push(args[i]);\r\n        }\r\n        return result;\r\n    },\r\n    generateUid: function (prefix, sufix) {\r\n        function getRandom4Chars() {\r\n            return Math.floor((1 + Math.random()) * 0x10000)\r\n                .toString(16)\r\n                .substring(1);\r\n        }\r\n        return ((prefix !== undefined) ? prefix + '-' : '') +\r\n            getRandom4Chars() + '-' +\r\n            getRandom4Chars() + '-' +\r\n            getRandom4Chars() +\r\n            getRandom4Chars() + ((sufix !== undefined) ? '-' + sufix : '');\r\n    },\r\n    propsToArray: function (obj, valueProcessor) {\r\n        var result = [];\r\n        for (var prop in obj) {\r\n            if (obj.hasOwnProperty(prop)) {\r\n                result.push({ property: prop, value: (valueProcessor) ? valueProcessor(obj[prop]) : obj[prop] });\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n};\r\n\r\nmainContainer.pa.paEachParalellsHelper = {\r\n    CheckParalellTaskStates: function (paralellId) {\r\n        var paralell = mainContainer.pa.paEachParalellsHelper.currentParalellIds[paralellId];\r\n        return paralell.CompletedTasks === paralell.TotalProcesses;\r\n    },\r\n    currentParalellIds: {},\r\n    actionKeys: {\r\n        Runeach: 'RunEach',\r\n        TaskState: 'TaskState'\r\n    },\r\n    eventKeys: {\r\n        RuneachDone: 'RuneachDone',\r\n        TaskState: 'TaskStateResponse'\r\n    }\r\n};\r\nmainContainer.pa.paWhereHelper = {\r\n    FillConditions: function (item, conditions) {\r\n        var l = conditions.length, condition, result, subArray;\r\n        while (l--) {\r\n            condition = conditions[l];\r\n            //conditions can be functions or single values, if there are single values, they have to ve evaluated by\r\n            //===. if they are functions everything should continue as by default\r\n            if (typeof condition.condition !== 'function') {\r\n                //if the condition is an object, it's necessary to handle it different.\r\n                //If that's the case we start internally another Where() call, but we know that we are\r\n                //evaluating pro Where call just ONE item and it could be very expensive. TODO: optimize this somehow!\r\n                if (mainContainer.pa.utils.GetTypeOf(condition.condition) === mainContainer.pa.utils.DataTypes.Object) {\r\n                    var itemType = mainContainer.pa.utils.GetTypeOf(item[condition.column], true);\r\n\r\n                    switch (itemType) {\r\n                        case mainContainer.pa.utils.DataTypes.ArrayOfObjects:\r\n                        case mainContainer.pa.utils.DataTypes.ArrayOfPrimitives:\r\n\r\n                            result = item[condition.column].Where.call(item[condition.column], condition.condition, false, true);\r\n                            //when sending true als \"justFirst\", Where() will return the first found element, not an array,\r\n                            //because i'm sending true for performance reasons, it's necessary to evaluate the result with undefined\r\n                            //instead of: \"return result.length > 0;\" it's now \"return result !== undefined;\"\r\n                            if (result !== undefined) {\r\n                                continue;\r\n                            } else {\r\n                                return false;\r\n                            }\r\n                            break;\r\n                        case mainContainer.pa.utils.DataTypes.Object:\r\n                            subArray = pa([item[condition.column]]);\r\n                            result = subArray.Where.call(subArray, condition.condition, false, true);\r\n                            if (result !== undefined) {//See previous comment about justFirst param\r\n                                continue;\r\n                            } else {\r\n                                return false;\r\n                            }\r\n                    }\r\n                }\r\n                condition.condition = pa.EqualTo3(condition.condition); //transforms an explicit value into an === evaluation\r\n            }\r\n\r\n            if (!item || !condition.condition(item[condition.column])) { //if one condition is not fulfilled, just return false;\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    ProcessConditionObject: function (whereConditions, keepOrder, isArrayOfConditions, justFirst, justIndexes) {\r\n        //to call this function, \"this\" should be an array!\r\n        var fc = mainContainer.pa.paWhereHelper.FillConditions,\r\n            i, w, item, lw, assert, l, result = [];\r\n\r\n        if (!isArrayOfConditions) {\r\n            //whereConditions is not an array, but i need it in that form\r\n            whereConditions = [whereConditions];\r\n        }\r\n\r\n        //Where conditions must be processed in order\r\n        for (i = 0, l = whereConditions.length; i < l; i++) {\r\n            var whereConditionObject = whereConditions[i], realConditions = [];\r\n            if (typeof whereConditionObject === 'function') {\r\n                realConditions.push({\r\n                    column: property,\r\n                    condition: whereConditionObject\r\n                });\r\n            } else {\r\n                for (var property in whereConditionObject) {\r\n                    if (property !== 'realConditions' && whereConditionObject.hasOwnProperty(property)) {\r\n                        //transform the keys into a better object with properties Column and Condition\r\n\r\n                        //if whereConditionObject[property] is an array, that means that its a multi filter for a single column, for example: array.Where({age : [GreatherThan(33), BiggerThan(21)], otherField : '33'   });\r\n                        if (whereConditionObject[property] && whereConditionObject[property].paIsArray) {\r\n                            /** MULTIPLE CONDITIONS FOR A SINGLE PROPERTY. Pushed on the realconditions as an AND **/\r\n                            whereConditionObject[property].RunEach(function (subCondition) {\r\n                                realConditions.push({\r\n                                    column: property,\r\n                                    condition: subCondition\r\n                                });\r\n                            });\r\n                        } else {\r\n                            realConditions.push({\r\n                                column: property,\r\n                                condition: whereConditionObject[property]\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            whereConditionObject.realConditions = realConditions; //attach the result of this loop direct to the whereConditionObject\r\n        }\r\n        //Real conditions stored\r\n        l = this.length;\r\n        if (keepOrder) { //Anti DRY pattern ;( but as long as it still being small will continue this way to improve performance\r\n            for (i = 0; i < l; i++) {\r\n                item = this[i];\r\n                for (w = 0, lw = whereConditions.length; w < lw; w++) {\r\n                    assert = fc(item, whereConditions[w].realConditions);\r\n                    if (assert) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (assert) {\r\n                    if (justFirst) {\r\n                        return (justIndexes) ? i : item;\r\n                    }\r\n                    result.push((justIndexes) ? i : item);\r\n                }\r\n            }\r\n        } else {\r\n            while (l--) {\r\n                item = this[l];\r\n                for (w = 0, lw = whereConditions.length; w < lw; w++) {\r\n                    assert = fc(item, whereConditions[w].realConditions);\r\n                    if (assert) {\r\n                        if (justFirst) {\r\n                            return (justIndexes) ? l : item;\r\n                        }\r\n                        result.push((justIndexes) ? l : item);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (justFirst) {\r\n            //Because in the loops, any positive evaluation makes a return.\r\n            //At this point there was no matches.\r\n            return undefined;\r\n        }\r\n\r\n        return result;\r\n    },\r\n    // The following function is a copy of the of the value_equals utiliy of\r\n    // the toubkal project.\r\n    // https://github.com/detky/toubkal/blob/master/lib/util/value_equals.js\r\n    equals: function (a, b, enforce_properties_order, cyclic) {\r\n        /* -----------------------------------------------------------------------------------------\r\n         equals( a, b [, enforce_properties_order, cyclic] )\r\n\r\n         Returns true if a and b are deeply equal, false otherwise.\r\n\r\n         Parameters:\r\n         - a (Any type): value to compare to b\r\n         - b (Any type): value compared to a\r\n\r\n         Optional Parameters:\r\n         - enforce_properties_order (Boolean): true to check if Object properties are provided\r\n         in the same order between a and b\r\n\r\n         - cyclic (Boolean): true to check for cycles in cyclic objects\r\n\r\n         Implementation:\r\n         'a' is considered equal to 'b' if all scalar values in a and b are strictly equal as\r\n         compared with operator '===' except for these two special cases:\r\n         - 0 === -0 but are not equal.\r\n         - NaN is not === to itself but is equal.\r\n\r\n         RegExp objects are considered equal if they have the same lastIndex, i.e. both regular\r\n         expressions have matched the same number of times.\r\n\r\n         Functions must be identical, so that they have the same closure context.\r\n\r\n         \"undefined\" is a valid value, including in Objects\r\n\r\n         106 automated tests.\r\n\r\n         Provide options for slower, less-common use cases:\r\n\r\n         - Unless enforce_properties_order is true, if 'a' and 'b' are non-Array Objects, the\r\n         order of occurence of their attributes is considered irrelevant:\r\n         { a: 1, b: 2 } is considered equal to { b: 2, a: 1 }\r\n\r\n         - Unless cyclic is true, Cyclic objects will throw:\r\n         RangeError: Maximum call stack size exceeded\r\n         */\r\n        return a === b       /* strick equality should be enough unless zero*/ // jshint ignore:line\r\n            && a !== 0         /* because 0 === -0, requires test by _equals()*/   // jshint ignore:line\r\n            || _equals(a, b) /* handles not strictly equal or zero values*/   // jshint ignore:line\r\n            ;\r\n        function _equals(a, b) {\r\n            // a and b have already failed test for strict equality or are zero\r\n\r\n            var s, l, p, x, y;\r\n\r\n            // They should have the same toString() signature\r\n            if ((s = toString.call(a)) !== toString.call(b)) return false; // jshint ignore:line\r\n\r\n            switch (s) {\r\n                default: // Boolean, Date, String\r\n                    return a.valueOf() === b.valueOf();\r\n\r\n                case '[object Number]':\r\n                    // Converts Number instances into primitive values\r\n                    // This is required also for NaN test bellow\r\n                    a = +a;\r\n                    b = +b;\r\n\r\n                    return a ?         // a is Non-zero and Non-NaN\r\n                        a === b\r\n                        :                // a is 0, -0 or NaN\r\n                        a === a ?      // a is 0 or -O\r\n                            1 / a === 1 / b    // 1/0 !== 1/-0 because Infinity !== -Infinity\r\n                            : b !== b        // NaN, the only Number not equal to itself!\r\n                        ;\r\n                // [object Number]\r\n\r\n                case '[object RegExp]':\r\n                    return a.source == b.source // jshint ignore:line\r\n                        && a.global == b.global // jshint ignore:line\r\n                        && a.ignoreCase == b.ignoreCase // jshint ignore:line\r\n                        && a.multiline == b.multiline // jshint ignore:line\r\n                        && a.lastIndex == b.lastIndex // jshint ignore:line\r\n                        ;\r\n                // [object RegExp]\r\n\r\n                case '[object Function]':\r\n                    return false; // functions should be strictly equal because of closure context\r\n                // [object Function]\r\n\r\n                case '[object Array]':\r\n                    // intentionally duplicated bellow for [object Object]\r\n                    if (cyclic && (x = reference_equals(a, b)) !== null) return x;  // jshint ignore:line\r\n\r\n                    if ((l = a.length) != b.length) return false; // jshint ignore:line\r\n                    // Both have as many elements\r\n\r\n                    while (l--) {\r\n                        if ((x = a[l]) === (y = b[l]) && x !== 0 || _equals(x, y)) continue; // jshint ignore:line\r\n\r\n                        return false;\r\n                    }\r\n\r\n                    return true;\r\n                // [object Array]\r\n\r\n                case '[object Object]':\r\n                    // intentionally duplicated from above for [object Array]\r\n                    if (cyclic && (x = reference_equals(a, b)) !== null) return x; // jshint ignore:line\r\n\r\n                    l = 0; // counter of own properties\r\n\r\n                    if (enforce_properties_order) {\r\n                        var properties = [];\r\n\r\n                        for (p in a) {\r\n                            if (a.hasOwnProperty(p)) {\r\n                                properties.push(p);\r\n\r\n                                if ((x = a[p]) === (y = b[p]) && x !== 0 || _equals(x, y)) continue; // jshint ignore:line\r\n\r\n                                return false;\r\n                            }\r\n                        }\r\n\r\n                        // Check if 'b' has as the same properties as 'a' in the same order\r\n                        for (p in b)\r\n                            if (b.hasOwnProperty(p) && properties[l++] != p) // jshint ignore:line\r\n                                return false; // jshint ignore:line\r\n                    } else {\r\n                        for (p in a) {\r\n                            if (a.hasOwnProperty(p)) {\r\n                                ++l;\r\n\r\n                                if ((x = a[p]) === (y = b[p]) && x !== 0 || _equals(x, y)) continue; // jshint ignore:line\r\n\r\n                                return false;\r\n                            }\r\n                        }\r\n\r\n                        // Check if 'b' has as not more own properties than 'a'\r\n                        for (p in b)\r\n                            if (b.hasOwnProperty(p) && --l < 0) // jshint ignore:line\r\n                                return false; // jshint ignore:line\r\n                    }\r\n\r\n                    return true;\r\n                // [object Object]\r\n            } // switch toString.call( a )\r\n        } // _equals()\r\n\r\n        /* -----------------------------------------------------------------------------------------\r\n         reference_equals( a, b )\r\n\r\n         Helper function to compare object references on cyclic objects or arrays.\r\n\r\n         Returns:\r\n         - null if a or b is not part of a cycle, adding them to object_references array\r\n         - true: same cycle found for a and b\r\n         - false: different cycle found for a and b\r\n\r\n         On the first call of a specific invocation of equal(), replaces self with inner function\r\n         holding object_references array object in closure context.\r\n\r\n         This allows to create a context only if and when an invocation of equal() compares\r\n         objects or arrays.\r\n         */\r\n        function reference_equals(a, b) {\r\n            var object_references = [];\r\n\r\n            return (reference_equals = _reference_equals)(a, b); // jshint ignore:line\r\n\r\n            function _reference_equals(a, b) {\r\n                var l = object_references.length;\r\n\r\n                while (l--)\r\n                    if (object_references[l--] === b) // jshint ignore:line\r\n                        return object_references[l] === a; // jshint ignore:line\r\n\r\n                object_references.push(a, b);\r\n\r\n                return null;\r\n            } // _reference_equals()\r\n        } // reference_equals()\r\n    } // equals()\r\n};\r\n\r\n\r\nmainContainer.pa.auxiliaryFunctions = {\r\n    Contains: function (value, enforcePropsOrder, cyclic) {\r\n        return function (val) {\r\n            if (!val.paIsArray) {\r\n                throw new Error(\"PowerArray error => parameter val passed to Contains function should be an array.\");\r\n            }\r\n            var l = val.length, isIndexable = false;\r\n            var typeToEvaluate = typeof value;\r\n\r\n            switch (typeToEvaluate) {\r\n                case \"number\":\r\n                case \"string\":\r\n                case \"boolean\":\r\n                    isIndexable = true;\r\n                    break;\r\n                default: //anything else\r\n                    //duck type to exclude dates\r\n                    if (typeof value.getMonth === 'function') {\r\n                        isIndexable = true;\r\n                        break;\r\n                    }\r\n                    isIndexable = false;\r\n                    break;\r\n            }\r\n            if (isIndexable) {\r\n                return val.indexOf(value) > -1;\r\n            }\r\n\r\n            while (l--) {\r\n                if (pa.paWhereHelper.equals(val[l], value, enforcePropsOrder, cyclic)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n\r\n        };\r\n    },\r\n    Between: function (from, to, excludeExactMatches) {\r\n        if (to < from) {\r\n            console.warn(\"PowerArray warn => Parameters 'from' and 'to' passed to function Between() makes no sense: Parameter 'to' (\" + to + \") should be greater than from (\" + from + \")\");\r\n        }\r\n        if (!excludeExactMatches) {\r\n            return function (val) {\r\n                return val >= from && val <= to;\r\n            };\r\n        } else {\r\n            return function (val) {\r\n                return val > from && val < to;\r\n            };\r\n        }\r\n    },\r\n    EndsWith: function (value) {\r\n        var value2 = value + '';\r\n        return function (endsWithString) {\r\n\r\n            endsWithString = endsWithString + '';\r\n            return endsWithString.substr(endsWithString.length - (value2).length) === value2;\r\n        };\r\n    },\r\n    StartsWith: function (value) {\r\n        var value2 = value + '';\r\n        return function (val) {\r\n            val = val + '';\r\n            return val.indexOf(value2) === 0;\r\n        };\r\n    },\r\n    GreaterOrEqualThan: function (value) {\r\n        return function (val) {\r\n            return val >= value;\r\n        };\r\n    },\r\n    GreaterThan: function (value) {\r\n        return function (val) {\r\n            return val > value;\r\n        };\r\n    },\r\n    SmallerOrEqualThan: function (value) {\r\n        return function (val) {\r\n            return val <= value;\r\n        };\r\n    },\r\n    SmallerThan: function (value) {\r\n        return function (val) {\r\n            return val < value;\r\n        };\r\n    },\r\n    EqualTo3: function (value) {\r\n        return function (val) {\r\n            return val === value;\r\n        };\r\n    },\r\n    NotEqualTo3: function (value) {\r\n        return function (val) {\r\n            return val !== value;\r\n        };\r\n    },\r\n    EqualTo2: function (value) {\r\n        return function (val) {\r\n            // ReSharper disable once CoercedEqualsUsing\r\n            return val == value; // jshint ignore:line\r\n        };\r\n    },\r\n    NotEqualTo2: function (value) {\r\n        return function (val) {\r\n            // ReSharper disable once CoercedEqualsUsing\r\n            return val != value; // jshint ignore:line\r\n        };\r\n    },\r\n    IsUndefined: function () {\r\n        return function (val) {\r\n            return val === undefined;\r\n        };\r\n    },\r\n    IsDefined: function () {\r\n        return function (val) {\r\n            return val !== undefined;\r\n        };\r\n    },\r\n    In: function (list) {\r\n        //TODO: investigar si esta function pierde performance al no estar devolviendo una\r\n        //funcion como todo el resto.\r\n\r\n        if (arguments.length > 1) {\r\n            list = Array.prototype.slice.call(arguments);\r\n        }\r\n        return function (val) {\r\n            return list.indexOf(val) !== -1; // jshint ignore:line\r\n        };\r\n    },\r\n    NotIn: function (list) {\r\n        if (arguments.length > 1) {\r\n            list = Array.prototype.slice.call(arguments);\r\n        }\r\n        return function (val) {\r\n            return list.indexOf(val) === -1; // jshint ignore:line\r\n        };\r\n    },\r\n    EqualTo: function (object, func, enforcePropsOrder, cyclic) {\r\n        return function (val) {\r\n            if (func) {\r\n                return func(val, object);\r\n            } else {\r\n                return pa.paWhereHelper.equals(object, val, enforcePropsOrder, cyclic);\r\n            }\r\n        };\r\n    },\r\n    Like: function (value) {\r\n        if (!value.paIsArray) {\r\n            value = Array.prototype.slice.call(arguments);\r\n        }\r\n        return function (val) {\r\n            var l = value.length;\r\n            while (l--) {\r\n                if (val.indexOf(value[l]) === -1) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n    },\r\n    NotLike: function (value) {\r\n        if (!value.paIsArray) {\r\n            value = Array.prototype.slice.call(arguments);\r\n        }\r\n        return function (val) {\r\n            var l = value.length;\r\n            while (l--) {\r\n                if (val.indexOf(value[l]) > -1) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n    },\r\n    LikeIgnoreCase: function (value) {\r\n        var valueCaseInsensitive = '';\r\n        if (!value.paIsArray) {\r\n            value = Array.prototype.slice.call(arguments);\r\n        }\r\n        return function (val) {\r\n            var l = value.length;\r\n            while (l--) {\r\n                valueCaseInsensitive = value[l].toUpperCase();\r\n                if (val.toUpperCase().indexOf(valueCaseInsensitive) === -1) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n    },\r\n    NotLikeIgnoreCase: function (value) {\r\n        var valueCaseInsensitive = '';\r\n        if (!value.paIsArray) {\r\n            value = Array.prototype.slice.call(arguments);\r\n        }\r\n        return function (val) {\r\n            var l = value.length;\r\n            while (l--) {\r\n                valueCaseInsensitive = value[l].toUpperCase();\r\n                if (val.toUpperCase().indexOf(valueCaseInsensitive) > -1) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n    },\r\n    IsTruthy: function () {\r\n        return function (val) {\r\n            return (val) ? true : false;\r\n        };\r\n    },\r\n    IsFalsy: function () {\r\n        return function (val) {\r\n            return (val) ? false : true;\r\n        }\r\n    },\r\n    IsTrue: function () {\r\n        return function (val) {\r\n            return val === true;\r\n        };\r\n    },\r\n    IsFalse: function () {\r\n        return function (val) {\r\n            return val === false;\r\n        }\r\n    },\r\n    IsEmpty: function () {\r\n        return function (val) {\r\n            return val === undefined || val === '' || val === null || val === 0 || (val.paIsArray && val.length === 0);\r\n        }\r\n    },\r\n    IsNotEmpty: function () {\r\n        return function (val) {\r\n            if (val === undefined || val === null) {\r\n                return false;\r\n            }\r\n            return (val + \"\").length > 0;\r\n        }\r\n    },\r\n    IsNull: function () {\r\n        return function (val) {\r\n            return val === null;\r\n        }\r\n    },\r\n    IsNotNull: function () {\r\n        return function (val) {\r\n            return val !== null;\r\n        }\r\n    },\r\n    IsNaN: function () {\r\n        return function (val) {\r\n            return isNaN(val);\r\n        }\r\n    },\r\n    IsNotNaN: function () {\r\n        return function (val) {\r\n            return !isNaN(val);\r\n        }\r\n    },\r\n    IsNumeric: function (num) {\r\n        return !isNaN(parseFloat(num)) && isFinite(num);\r\n    },\r\n    IsInteger: function (num) {\r\n        return num === parseInt(num, 10);\r\n    }\r\n\r\n};\r\n\r\nmainContainer.pa.prototypedFunctions_Array = {\r\n    getIndexByProperty: function (valueToSearchFor) {// jshint ignore:line\r\n        /**\r\n         * This function, evaluates properties (or function results) over each object on an array, and answers with an\r\n         * array of the found elements that matches the specified condition. The condition is given by the parameters\r\n         * provided after position 2. The only fixed parameters are the objects array and the value to search for.\r\n         * You can provide so many parameters as you want. Each parameter means one level deeper to search for. For example:\r\n         *\r\n         *      let's say that you have a collection of \"car\" objects, having each car a function called \"getPassengers\"\r\n         *      which answers with a collection of \"people\" objects, and each people have a property called \"name\".\r\n         *\r\n         *  To get an array of cars having a passenger called Paul, use as following:\r\n         *\r\n         *  var namedPaul = findDistinctValuesOnObjectCollectionByProperty(theCarsCollection, 'Paul', 'getPassengers()','name');\r\n         *\r\n         * @param objectsArray\r\n         * @param valueToSearchFor\r\n         * @returns {number}\r\n         */\r\n        var objectsArray = this;\r\n        //if (!objectsArray) {\r\n        //    return -1;\r\n        //}\r\n        var ia, la = arguments.length; // ia = i for arguments; la = length for arguments\r\n        var io, lo = objectsArray.length; // io = i for objects; lo = length for objects\r\n\r\n        for (io = 0; io < lo; io++) { //iterate objects array\r\n            var tmpObj = objectsArray[io];\r\n\r\n            for (ia = 1; ia < la; ia++) { //iterate throw arguments to get the right property. Start from 1, to exclude the objectsArray self\r\n                var arg = arguments[ia];\r\n                var isFunc = arg.substring(arg.length - 2) === \"()\";\r\n                var argName = (isFunc) ? arg.substr(0, arg.length - 2) : arg;\r\n                tmpObj = (isFunc) ? tmpObj[argName]() : tmpObj[arg];\r\n                // Converting comparison needed (e.g. string id vs integer id)\r\n                // ReSharper disable once CoercedEqualsUsing\r\n                if (ia + 1 === la && tmpObj == valueToSearchFor) { // jshint ignore:line\r\n                    return io;\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    },\r\n    GetPropertyFlat: function (property, keepOrder, includeDuplicates, includeUndefineds) { // jshint ignore:line\r\n        var array = this;\r\n        var result = [], t = array.length;\r\n        if (keepOrder === true) {\r\n            for (var i = 0; i < t; i++) {\r\n                if (includeDuplicates || result.indexOf(array[i][property]) === -1) {\r\n                    if (includeUndefineds === true || array[i][property] !== undefined) {\r\n                        result.push(array[i][property]);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            while (t--) {\r\n                if (includeDuplicates || result.indexOf(array[t][property]) === -1) {\r\n                    if (includeUndefineds === true || array[t][property] !== undefined) {\r\n                        result.push(array[t][property]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    },\r\n    GetByProperty: function (valueToSearchFor) {// jshint ignore:line\r\n        /**\r\n         * This function, evaluates properties (or function results) over each object on an array, and answers with an\r\n         * array of the found elements that matches the specified condition. The condition is given by the parameters\r\n         * provided after position 2. The only fixed parameters are the objects array and the value to search for.\r\n         * You can provide so many parameters as you want. Each parameter means one level deeper to search for. For example:\r\n         *\r\n         *      let's say that you have a collection of \"car\" objects, having each car a function called \"getPassengers\"\r\n         *      which answers with a collection of \"people\" objects, and each people have a property called \"name\".\r\n         *\r\n         *  To get an array of cars having a passenger called Paul, use as following:\r\n         *\r\n         *  var passengersNamedPaul = carsArray.getByProperty('Paul', 'getPassengers()','name');\r\n         *\r\n         * @param objectsArray\r\n         * @param valueToSearchFor\r\n         * @returns {Array}\r\n         */\r\n        var objectsArray = this;\r\n        var results = [];\r\n        var ia, la = arguments.length; // ia = i for arguments; la = length for arguments\r\n        var io, lo = objectsArray.length; // io = i for objects; lo = length for objects\r\n        for (io = 0; io < lo; io++) { //iterate objects array\r\n            var tmpObj = objectsArray[io];\r\n\r\n            for (ia = 1; ia < la; ia++) { //iterate throw arguments to get the right property. Start from 1, to exclude the objectsArray self\r\n                var arg = arguments[ia];\r\n                var isFunc = arg.substring(arg.length - 2) === \"()\";\r\n                var argName = (isFunc) ? arg.substr(0, arg.length - 2) : arg;\r\n                tmpObj = (isFunc) ? tmpObj[argName]() : tmpObj[arg];\r\n                if (ia + 1 === la && tmpObj === valueToSearchFor) {\r\n                    results.push(objectsArray[io]);\r\n                }\r\n            }\r\n        }\r\n        return results;\r\n    },\r\n    /**\r\n     * Executes a function (task) on each element of the array (this).\r\n     * @param {} task       A function to execute. It will receive 3 parameters:\r\n     *                          1) one array item\r\n     *                          2) index of the passed item (param 1) on the original array.\r\n     *                          3) the complete array. Warning, you should not change it. See it as read-only!\r\n     *\r\n     * @param {} callback   A callback function to be executed after processing all array items.\r\n     *                      It will get as first parameter the results-array (that lately will be\r\n     *                      returned as result of this function).\r\n     *                       *****************************PLEASE READ**********************************\r\n     *                      *** If the callback function returns something different than undefined, ***\r\n     *                      ***      the results-array will be replaced with that return value       ***\r\n     *                       **************************************************************************\r\n     * @param {} keepOrder\r\n     * @returns             array of the result of each executed task (keeping same position as on original\r\n     *                      array, regardless order). Excepion: when the execution of the callback function\r\n     *                      returns something different than undefined, that will be returned instead of the\r\n     *                      . If not,\r\n     */\r\n    RunEach: function (task, callback, keepOrder, progress) {// jshint ignore:line\r\n        var l = this.length, i = 0, result = new Array(this.length), tmp;\r\n        if (!keepOrder) {\r\n            while (l--) {\r\n                result[l] = task(this[l], l, this);\r\n            }\r\n        } else {\r\n            for (; i < l; i++) {\r\n                result[i] = task(this[i], i, this);\r\n            }\r\n        }\r\n        if (callback) {\r\n            //if the callback function returns something,\r\n            //the result will be overrided with that result.\r\n            result = callback(result) || result;\r\n        }\r\n        return result;\r\n    },\r\n    Sort: function (sortConditions) { // jshint ignore:line\r\n        var realConditions = [];\r\n        var conditionType = typeof sortConditions;\r\n\r\n        switch (conditionType) {\r\n            case \"string\":\r\n                //This call, with a first parameter of type string, should be \"ASC\" or \"DESC\"\r\n                var condition = sortConditions.toUpperCase();\r\n                switch (condition) {\r\n                    case pa.Sort.Ascending:\r\n                    case pa.Sort.Asc:\r\n                        return this.sort(function (a, b) {\r\n                            if (a < b) {\r\n                                return -1;\r\n                            } else if (a > b) {\r\n                                return 1;\r\n                            }\r\n                            return 0;\r\n                        });\r\n                    case pa.Sort.AscendingIgnoringCase:\r\n                    case pa.Sort.AscIgnoringCase:\r\n                        return this.sort(function (a, b) {\r\n                            try {\r\n                                return a.toLowerCase().localeCompare(b.toLowerCase());\r\n                            } catch (e) {\r\n                                if (console && console.warn) {\r\n                                    console.warn('PowerArray => Error trying to sort by ' + condition + '. When sorting by ' + condition + ', all values has to be strings. Probably it\\'s not the case!. Now casting to string, performance may be affected.');\r\n                                    a = a + '';\r\n                                    b = b + '';\r\n                                    return a.toLowerCase().localeCompare(b.toLowerCase());\r\n                                }\r\n                            }\r\n                        });\r\n                    case pa.Sort.Descending:\r\n                    case pa.Sort.Desc:\r\n                        return this.sort(function (a, b) {\r\n                            if (a > b) {\r\n                                return -1;\r\n                            } else if (a < b) {\r\n                                return 1;\r\n                            }\r\n                            return 0;\r\n                        });\r\n                    case pa.Sort.DescendingIgnoringCase:\r\n                    case pa.Sort.DescIgnoringCase:\r\n                        return this.sort(function (a, b) {\r\n                            return (a.toLowerCase().localeCompare(b.toLowerCase())) * -1;\r\n                        });\r\n                    default:\r\n                        throw new Error(\"PowerArray Error: Invalid sort condition. If you pass a first parameter of type String to the Sort function,\" +\r\n                            \" PowerArray assumes that you have a simple array on your hand (one dimension of primitives). Possible parameter values for function Sort \" +\r\n                            \" in that situation, are: 1) To sort Ascending: 'Asc' and 'AscIgnoreCase' (aliases: 'Ascending', 'AscendingIgnoreCase'), and 2)\" +\r\n                            \" To sort Descending: 'Desc','Descending' (aliases: 'Descending', 'DescendingIgnoreCase') \");\r\n                }\r\n                break;\r\n            case \"object\":\r\n\r\n                if (sortConditions instanceof RegExp) {\r\n                    throw new Error(\"PowerArray Error: Invalid sortConditions object. A RegExp is not allowed as Sort Criterion!\");\r\n                }\r\n\r\n                if (!sortConditions) {\r\n                    if (sortConditions.hasOwnProperty('length')) {\r\n                        throw new Error(\"PowerArray Error: Invalid sortConditions object\");\r\n                    }\r\n                }\r\n\r\n                for (var property in sortConditions) {\r\n                    if (sortConditions.hasOwnProperty(property)) {\r\n\r\n                        //transform the keys into a better object with properties Column and SortOrder\r\n                        var value = sortConditions[property].toUpperCase();\r\n\r\n                        if (!mainContainer.pa.Sort._validSortConfigStrings.indexOf(sortConditions[property]) === -1) {\r\n                            throw new Error(\"PowerArray Configuration Error => Invalid sort direction for property \" + property + \": '\" + sortConditions[property] + \"'\");\r\n                        }\r\n\r\n                        realConditions.push({\r\n                            column: property,\r\n                            sortDirection: value\r\n                        });\r\n                    }\r\n                }\r\n\r\n                return this.sort(function (a, b) {\r\n                    var result = 0, currentColumn, cycleValue;\r\n                    for (var i = 0, l = realConditions.length; i < l; i++) {\r\n                        cycleValue = 10 - i;\r\n                        currentColumn = realConditions[i].column;\r\n                        switch (realConditions[i].sortDirection) {\r\n                            case mainContainer.pa.Sort.Ascending:\r\n                            case mainContainer.pa.Sort.Asc:\r\n                            case mainContainer.pa.Sort.AscendingIgnoringCase:\r\n                            case mainContainer.pa.Sort.AscIgnoringCase:\r\n                                if (a[currentColumn] < b[currentColumn]) {\r\n                                    result -= cycleValue;\r\n                                } else if (a[currentColumn] > b[currentColumn]) {\r\n                                    result += cycleValue;\r\n                                }\r\n                                break;\r\n                            case mainContainer.pa.Sort.Descending:\r\n                            case mainContainer.pa.Sort.Desc:\r\n                            case mainContainer.pa.Sort.DescendingIgnoringCase:\r\n                            case mainContainer.pa.Sort.DescIgnoringCase:\r\n                                if (a[currentColumn] < b[currentColumn]) {\r\n                                    result += cycleValue;\r\n                                } else if (a[currentColumn] > b[currentColumn]) {\r\n                                    result -= cycleValue;\r\n                                }\r\n                                break;\r\n                        }\r\n                    }\r\n                    return result;\r\n                });\r\n            case \"undefined\":\r\n                //No parameters passed, sorting by default\r\n                return this.sort();\r\n            case \"function\":\r\n                return this.sort(sortConditions); //simple forward to array.sort\r\n            default:\r\n                throw new Error(\"Unknown sortConditions object type (\" + conditionType + \")\");\r\n        }\r\n    },\r\n    Exists: function (whereConditions) {\r\n        if (pa.prototypedFunctions_Array.First.call(this, whereConditions)) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    },\r\n    Remove: function (whereConditions) {\r\n        var first = this.FirstIndex(whereConditions);\r\n        while (first !== undefined) {\r\n            this.splice(first, 1);\r\n            first = this.FirstIndex(whereConditions);\r\n        }\r\n        return this;\r\n    },\r\n    //this primitive distinct version works only for array of primitives.\r\n    Distinct: function () {\r\n        var val, l = this.length, results = [];\r\n        if (pa.utils.GetTypeOf(this) !== pa.utils.DataTypes.ArrayOfPrimitives) {\r\n            throw new Error(\"PowerArray => Distinct => Currently, the distinct function works only for arrays of primitive data.\");\r\n        }\r\n        while (l--) {\r\n            val = this[l];\r\n            if (results.indexOf(val) === -1 && val !== undefined) {\r\n                results.push(val);\r\n            }\r\n        }\r\n        return results;\r\n    },\r\n    /** Iterates an array and executes the function on each item as runeach does, but always returns the original array  */\r\n    Iterate: function(func, keepOrder){\r\n        this.RunEach(func, undefined, keepOrder);\r\n        return this;\r\n    },\r\n    /**returns a collection of the results of the execution of \"func\" in a given order */\r\n    Collect: function(func, keepOrder) {\r\n        return this.RunEach(func, undefined, keepOrder);\r\n    },\r\n    WhereIndexes: function (whereConditions, keepOrder, justFirst) {\r\n        return this.Where(whereConditions, keepOrder, justFirst, true);\r\n    },\r\n    Where: function (whereConditions, keepOrder, justFirst, justIndexes) {// jshint ignore:line\r\n        var i, l = this.length, item, result = [], tmp;\r\n        justIndexes = (justIndexes) ? true : false; //just to avoid casting when comparing during loop\r\n        if (typeof whereConditions === 'object' && !(whereConditions.paIsArray)) {\r\n            //If It's an object, but not an array, it is a conditions object\r\n            result = pa.paWhereHelper.ProcessConditionObject.call(this, whereConditions, keepOrder, false, justFirst, justIndexes);\r\n        } else {\r\n\r\n            //At this point, whereConditions could be a:\r\n            //                                          => function (a custom function),\r\n            //                                          => an pa.EqualTo,\r\n            //                                          => an Array of condition-objects\r\n\r\n            if (typeof whereConditions === 'undefined') {\r\n                var a = new Error(\"PowerArray => Where function => No condition object provided to function 'Where(whereConditions, keepOrder)'\");\r\n                a.message = \"InvalidWhereCondition\";\r\n                throw a;\r\n            } else if (whereConditions.paIsArray) {\r\n                //It's a conditions array\r\n                tmp = pa.paWhereHelper.ProcessConditionObject.call(this, whereConditions, keepOrder, true, justFirst, justIndexes);\r\n                if (justFirst)\r\n                    return tmp;\r\n                result.push.apply(result, tmp);\r\n            } else {\r\n                //whereConditions it's a function. It could be a custom function on the pa standard EqualTo (that works\r\n                //different than any other standard function)\r\n                if (keepOrder) {\r\n                    for (i = 0; i < l; i++) {\r\n                        item = this[i];\r\n                        if (whereConditions(item)) {\r\n                            if (justFirst) {\r\n                                return (justIndexes) ? i : item;\r\n                            }\r\n                            result.push(item);\r\n                        }\r\n                    }\r\n                } else {\r\n                    while (l--) {\r\n                        item = this[l];\r\n                        if (whereConditions(item)) {\r\n                            if (justFirst) {\r\n                                return (justIndexes) ? l : item;\r\n                            }\r\n                            result.push(item);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    },\r\n    Count: function (whereConditions) {\r\n        if (arguments.length !== 1) {\r\n            throw new Error('PowerArray => Count function => Invalid arguments. The only argument is a whereCondition or an array of whereConditions object.');\r\n        }\r\n        return pa.prototypedFunctions_Array.Where.call(this, whereConditions, false, false).length;\r\n    },\r\n    First: function (whereConditions) {// jshint ignore:line\r\n        if (arguments.length === 0) {\r\n            return (this.length > 0) ? this[0] : undefined;\r\n        }\r\n        return pa.prototypedFunctions_Array.Where.call(this, whereConditions, true, true);\r\n    },\r\n    FirstIndex: function (whereConditions) {// jshint ignore:line\r\n        if (arguments.length === 0) {\r\n            return (this.length > 0) ? 0 : undefined;\r\n        }\r\n        return pa.prototypedFunctions_Array.Where.call(this, whereConditions, true, true, true);\r\n    },\r\n    Average: function () {\r\n        //TODO: the same way to work as Max()\r\n    },\r\n    /*Return an object containing min and max values of one or more propeties in an objects array */\r\n    Bounds: function () {\r\n        var l = this.length, alc, al = arguments.length, maxVal, result = {}, arrayItemValue, currentArgName = '';\r\n        if (al === 0) {\r\n            throw new Error(\"PowerArray => bounds => invalid params, please provide one or more target parameters\");\r\n        }\r\n        alc = al;\r\n        while (alc--) {\r\n            currentArgName = arguments[alc];\r\n            result[currentArgName] = { min: undefined, max: undefined };\r\n        }\r\n        while (l--) {\r\n            alc = al;\r\n            while (alc--) {\r\n                currentArgName = arguments[alc];\r\n                arrayItemValue = this[l][currentArgName];\r\n                if (result[currentArgName].max === undefined || (arrayItemValue !== undefined && arrayItemValue > result[currentArgName].max)) {\r\n                    result[currentArgName].max = arrayItemValue;\r\n                }\r\n                if (result[currentArgName].min === undefined || (arrayItemValue !== undefined && arrayItemValue < result[currentArgName].min)) {\r\n                    result[currentArgName].min = arrayItemValue;\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n\r\n    },\r\n    /**\r\n     * Return max values of specified properties\r\n     * @param {} target\r\n     * @returns {}\r\n     */\r\n    Max: function () {\r\n        var l = this.length, alc, al = arguments.length, maxVal, result = {}, arrayItemValue, currentArgName = '';\r\n        if (al === 0) {\r\n            throw new Error(\"PowerArray => Max => invalid params, please provide one or more target parameters\");\r\n        }\r\n        alc = al;\r\n        while (alc) {\r\n            //evaluate if the passed arguments are integers. this means that the collection has indexable objects (arrays or array like objects)\r\n\r\n        }\r\n        while (l--) {\r\n            alc = al;\r\n            while (alc--) {\r\n                currentArgName = arguments[alc];\r\n                arrayItemValue = this[l][currentArgName];\r\n                if (result[currentArgName] === undefined || (arrayItemValue !== undefined && arrayItemValue > result[currentArgName])) {\r\n                    result[currentArgName] = arrayItemValue;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (al === 1) { //if only one max is expected, just return it\r\n            return result[currentArgName];\r\n        } else if (al > 1) {\r\n\r\n        }\r\n    },\r\n    Take: function (count, skip) {\r\n        skip = skip || 0;\r\n        var i = 0 + skip, l = this.length, result = [], added = 0;\r\n        for (; i < l && added < count; i++) {\r\n            result.push(this[i]);\r\n            added++;\r\n        }\r\n        return result;\r\n    },\r\n    Last: function () {\r\n        var idx = this.length - 1;\r\n        return (idx > -1) ? this[idx] : null;\r\n    }\r\n};\r\n\r\n// ReSharper disable once WrongExpressionStatement\r\nmainContainer.pa.Sort = {\r\n    Ascending: 'ASCENDING',\r\n    Asc: 'ASC',\r\n    AscendingIgnoringCase: 'ASCENDINGIGNORINGCASE',\r\n    AscIgnoringCase: 'ASCIGNORINGCASE',\r\n    Descending: 'DESCENDING',\r\n    Desc: 'DESC',\r\n    DescendingIgnoringCase: 'DESCENDINGIGNORINGCASE',\r\n    DescIgnoringCase: 'DESCIGNORINGCASE',\r\n}\r\nif (mainContainer.Sort === undefined) {\r\n    mainContainer.Sort = mainContainer.Sort || mainContainer.pa.Sort;\r\n    mainContainer.pa.Sort._validSortConfigStrings = [\r\n        mainContainer.pa.Sort.Ascending,\r\n        mainContainer.pa.Sort.Asc,\r\n        mainContainer.pa.Sort.AscendingIgnoringCase,\r\n        mainContainer.pa.Sort.AscIgnoringCase,\r\n        mainContainer.pa.Sort.Descending,\r\n        mainContainer.pa.Sort.Desc,\r\n        mainContainer.pa.Sort.DescendingIgnoringCase,\r\n        mainContainer.pa.Sort.DescIgnoringCase];\r\n} else {\r\n    if(console && console.warn) console.warn('PowerArray warning! => prop \"Sort\" already exists on parent scope. You have to use \"pa.Sort\" instead of \"Sort\" on your code.\"');\r\n}\r\n\r\n\r\n//this is intended to help IDE'S to understand the working way of powerarray. This will never be executed!\r\nif (false) {\r\n    Array.prototype.Where = function (WhereConditions) {\r\n\t\r\n    };\r\n}\r\n\r\nvar paArray = function (array) {\r\n    if (!array.paIsArray) {\r\n        throw new Error('PowerArray => paArray warning => Invalid array passed to pa() function\"');\r\n    }\r\n    var newArray = array.slice(0);\r\n\r\n    var functionsToAttach = mainContainer.pa.prototypedFunctions_Array;\r\n    for (var currentFunctionName in functionsToAttach) {\r\n        if (functionsToAttach.hasOwnProperty(currentFunctionName)) {\r\n            newArray[currentFunctionName] = functionsToAttach[currentFunctionName]; // jshint ignore:line\r\n        }\r\n    }\r\n    return newArray;\r\n};\r\n\r\npaArray.prototype.isArray = true;\r\n\r\n//region \"Initialization\"\r\n(function () {\r\n    //Register all Pa auxiliary functions to make them accessible through the mainContainer object and mainContainer.pa object\r\n    //If a mainContainer accessor is already taken and cannot be set, warn the user.\r\n    var obj = mainContainer.pa.auxiliaryFunctions;\r\n    for (var p in obj) {\r\n        if (obj.hasOwnProperty(p)) {\r\n            mainContainer.pa[p] = obj[p];\r\n            if (!mainContainer[p]) {\r\n                mainContainer[p] = obj[p];\r\n            } else {\r\n                console.warn('PowerArray warning! => property mainContainer.' + p + ' already exists. PowerArrayFunction pa.' + p + ' cannot register this function on mainContainer scope. However, you can still using it by calling \"pa.' + p + '\"');\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!Array.prototype.paIsArray) {\r\n        //TODO: this cannot stay fix like that ;(\r\n        Array.prototype.paIsArray = true;// jshint ignore:line\r\n    }\r\n\r\n    //Register all Array prototype functions to make them accessible to each array.\r\n    //If function name is already is already taken, warn the user and describe alternative usage way.\r\n    var functionsToAttach = mainContainer.pa.prototypedFunctions_Array;\r\n    for (var currentFunctionName in functionsToAttach) {\r\n        if (functionsToAttach.hasOwnProperty(currentFunctionName)) {\r\n            if (Array.prototype.hasOwnProperty(currentFunctionName)) {\r\n                console.warn('PowerArray warning! => Array Prototype was modified by other library: the function name \"' + currentFunctionName +\r\n                    '\" is already in use. PowerArray will NOT override the prototype method. However, you can still using the function' + \r\n\t\t\t\t\t' by surrounding your array with a pa constructor call, as following: pa(yourArrayName).' + currentFunctionName + \"(...)\");\r\n            } else {\r\n                //function name is free, go on:\r\n                Array.prototype[currentFunctionName] = functionsToAttach[currentFunctionName]; // jshint ignore:line\r\n            }\r\n            // Attach all functions also to the paArray prototype, that is the wrapper for solve conflicts (pa(array))\r\n            // from array prototype\r\n            paArray.prototype[currentFunctionName] = functionsToAttach[currentFunctionName]; // jshint ignore:line\r\n        }\r\n    }\r\n})();\r\nif (isModule) {\r\n    module.exports = mainContainer.pa;\r\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/PowerArray.js\n// module id = 1\n// module chunks = 0","require('./PowerArray.js');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/main.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}